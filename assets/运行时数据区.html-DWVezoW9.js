import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o,a as c}from"./app-ZK3Ibs3L.js";const d={},r=c('<h1 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h1><p><code>Java</code>虚拟机在运行<code>Java</code>程序过程中管理的内存区域，被称之为运行时数据区。</p><h2 id="程序计数器-program-counter-register" tabindex="-1"><a class="header-anchor" href="#程序计数器-program-counter-register"><span>程序计数器（Program Counter Register）</span></a></h2><p>程序计数器也叫<code>PC</code>寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址。</p><p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</p><p>在多线程执行情况下，<code>Java</code>虚拟机需要通过程序计数器记录<code>CPU</code>切换前解释执行到那一句指令并继续解释运行。</p><h2 id="java虚拟机栈-java-virtual-machine-stack" tabindex="-1"><a class="header-anchor" href="#java虚拟机栈-java-virtual-machine-stack"><span>Java虚拟机栈（Java Virtual Machine Stack）</span></a></h2><p><code>Java</code>虚拟机栈采用栈的数据结构来管理方法调用中的基本数据，先进后出（<code>First in Out</code>），每一个方法的调用使用一个栈帧（<code>Stack Frame</code>）来保存。</p><p><code>Java</code>虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。</p><p>栈帧的组成：局部变量表、操作数栈、帧数据</p><h4 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表"><span>局部变量表</span></a></h4><p>局部变量表的作用是在运行过程中存放所有的局部变量。</p><p>栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽（<code>slot</code>），<code>long</code>和<code>double</code>类型占用两个槽，其他类型占用一个槽。</p><p>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。</p><p>局部变量表保存的内容有：实例方法的<code>this</code>对象，方法的参数，方法体中声明的局部变量。</p><blockquote><p>为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。</p></blockquote><h4 id="操作数栈" tabindex="-1"><a class="header-anchor" href="#操作数栈"><span>操作数栈</span></a></h4><p>操作数栈是栈帧中虚拟机在执行指令过程中用来存放中件数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。</p><p>在<strong>编译期</strong>就可以确认操作数栈的最大深度，从而在执行时正确的分配内存大小。</p><h4 id="帧数据" tabindex="-1"><a class="header-anchor" href="#帧数据"><span>帧数据</span></a></h4><p>当前类的字节码指令引用了其他类的属性或方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就要保存了编号到运行时常量池的内存地址的映射关系。</p><p><strong>方法出口</strong>指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。</p><p><strong>异常表</strong>存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p><h4 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h4><p><code>Java</code>虚拟机栈存储了<code>Java</code>方法调用时的栈帧，而本地方法栈存储的是<code>native</code>本地方法的栈帧。</p><p>在<code>Hotspot</code>虚拟机中，<mark><code>Java</code>虚拟机栈和本地方法栈实现上使用了同一个栈空间</mark>。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><p>一般<code>Java</code>程序中堆内存时空间最大的一块内存区域。创建出来的对象都存在与堆上。</p><p>栈上的局部变量表中中，可以存放对上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p><p>堆空间有三个需要关注的值：<code>used</code>、<code>total</code>、<code>max</code>。</p><p><code>used</code>指的是当前已使用的堆内存，<code>total</code>是<code>Java</code>虚拟机已经分配的可用堆内存，<code>max</code>是<code>Java</code>虚拟机可以分配的最大堆内存。</p><p>随着堆中的对象增多，当<code>total</code>可以使用的内存即将不足时，<code>Java</code>虚拟机会继续分配内存给堆。</p><h2 id="方法区-method-area" tabindex="-1"><a class="header-anchor" href="#方法区-method-area"><span>方法区（Method Area）</span></a></h2><p>方法区时存放基础信息的位置，线程共享，主要包含：类的元信息、运行时常量池、字符串常量池。</p><p><strong>类的元信息</strong></p><p>方法区是用来存储每个类的<strong>基本信息（元信息）</strong>，一般称之为<code>InstanceKlass</code>对象。在类的<strong>加载阶段</strong>完成。</p><p><strong>运行时常量池</strong></p><p>常量池中存放的是字节码中的常量池内容。</p><p>字节码文件中通过编号查表得方式找到常量，这种常量池称为<strong>静态常量池</strong>。当常量池加载到内存中之后，可以通过内存地址快速得定位到常量池中的内容，这种常量池称为<strong>运行时常量池</strong>。</p><p><strong>字符串常量池</strong></p><p>字符串常量池存储在代码中定义的常量字符串内容。比如 ”123“ 这个123就会被放入字符串常量池。</p><p><code>JDK7</code>之后版本由于字符串常量池在堆上，所有<code>intern()</code>方法会把第一次遇到的<strong>字符串的引用</strong>放入字符串常量池。</p><p><code>JDK7</code>之后版本，静态变量是存放在堆中的<code>Class</code>对象中，脱离了永久代。</p><h2 id="直接内存-direct-memory" tabindex="-1"><a class="header-anchor" href="#直接内存-direct-memory"><span>直接内存（Direct Memory）</span></a></h2><p>直接内存并不在《Java虚拟机规范》中存在，所以并不属于<code>Java</code>运行时的内存区域。</p><p>在<code>JDK 1.4 </code>中引入了<code>NIO</code>机制，使用了直接内存，主要解决以下两个问题：</p><ul><li><code>Java</code>堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。</li><li><code>IO</code>操作比如读文件，需要先把文件读入直接内存（缓存区）再把数据复制到Java堆中。</li></ul><blockquote><p>现在直接放入直接内存即可，同时<code>Java</code>堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。</p></blockquote>',48),t=[r];function n(p,s){return o(),a("div",null,t)}const h=e(d,[["render",n],["__file","运行时数据区.html.vue"]]),m=JSON.parse('{"path":"/technology/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html","title":"运行时数据区","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"程序计数器（Program Counter Register）","slug":"程序计数器-program-counter-register","link":"#程序计数器-program-counter-register","children":[]},{"level":2,"title":"Java虚拟机栈（Java Virtual Machine Stack）","slug":"java虚拟机栈-java-virtual-machine-stack","link":"#java虚拟机栈-java-virtual-machine-stack","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":2,"title":"方法区（Method Area）","slug":"方法区-method-area","link":"#方法区-method-area","children":[]},{"level":2,"title":"直接内存（Direct Memory）","slug":"直接内存-direct-memory","link":"#直接内存-direct-memory","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.22,"words":1565},"filePathRelative":"technology/jvm/运行时数据区.md","excerpt":"\\n<p><code>Java</code>虚拟机在运行<code>Java</code>程序过程中管理的内存区域，被称之为运行时数据区。</p>\\n<h2>程序计数器（Program Counter Register）</h2>\\n<p>程序计数器也叫<code>PC</code>寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址。</p>\\n<p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</p>\\n<p>在多线程执行情况下，<code>Java</code>虚拟机需要通过程序计数器记录<code>CPU</code>切换前解释执行到那一句指令并继续解释运行。</p>"}');export{h as comp,m as data};
