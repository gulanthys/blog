import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as l}from"./app-ZK3Ibs3L.js";const h={},n=l(`<h1 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h1><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><p>HashMap的数据结构为Node数组+Node链表+TreeNode红黑树。他的整体结构是一个Node数组，在数组的每个位置是一个链表。当链表的长度&gt;=8或数组容量&gt;=64时，链表会转换成红黑树。 Node对象包含4个元素（hash、key、value、next） TreeNode对象包含5个元素（parent、left、right、prev、red）</p><h2 id="put流程" tabindex="-1"><a class="header-anchor" href="#put流程"><span>put流程</span></a></h2><ol><li>根据给定的哈希值和键值对，计算出该元素应当插入的哈希槽。</li><li>如果哈希数组未初始化或容量不足，则需要先初始化或扩容哈希数组。</li><li>在哈希槽中查找是否存在与新元素同位的元素（即哈希值和键都相同的元素）。</li><li>如果不存在同位元素，则将新元素插入到哈希槽中。</li><li>如果存在同位元素： <ol><li>如果需要维持原状（即不覆盖旧值），则返回同位元素的旧值。</li><li>如果不需要维持原状，或者旧值为null，则更新同位元素的值为新值，并返回旧值。</li></ol></li><li>如果插入新元素后，哈希数组的容量超过了阈值，则需要对哈希数组进行扩容。</li><li>返回同位元素的旧值，如果不存在同位元素，则返回null。</li></ol><h2 id="get流程" tabindex="-1"><a class="header-anchor" href="#get流程"><span>get流程</span></a></h2><ol><li>根据key值通过扰动函数计算hash值。</li><li>首先判断table是否为空以及其长度是否大于0，以及通过(key计算而来的)hash值计算出的哈希槽位置上的元素是否为空。</li><li>如果以上条件都满足，则进一步判断首个元素是否与给定的key和hash值匹配。如果匹配，则返回该元素。</li><li>如果首个元素不匹配，则判断其后续元素是否为红黑树节点。如果是，则在红黑树中进行查找。</li><li>如果后续元素不是红黑树节点，则遍历哈希槽上的后续元素，直到找到匹配的元素或遍历结束。</li><li>如果最终没有找到匹配的元素，则返回null。</li></ol><h2 id="remove流程" tabindex="-1"><a class="header-anchor" href="#remove流程"><span>remove流程</span></a></h2><ol><li>根据给定的key和hash查找对应的同位元素。</li><li>如果找到了匹配的元素，则根据matchValue参数决定是否需要进一步匹配value。</li><li>如果需要匹配value且值不匹配，则不移除元素，直接返回null。</li><li>如果匹配成功，则根据节点类型（TreeNode或普通Node）进行相应的移除操作。</li><li>更新相关计数器和变量，如modCount和size。</li><li>调用afterNodeRemoval()进行后续处理。</li><li>返回刚刚移除的节点（如果未找到匹配节点则返回null）。</li></ol><h2 id="扩容实现流程" tabindex="-1"><a class="header-anchor" href="#扩容实现流程"><span>扩容实现流程</span></a></h2><ol><li>判断哈希数组是否已经初始化， <ol><li>如果已经初始化，则根据当前容量和最大容量来决定是否需要扩容；</li><li>如果还未初始化，则根据是否指定了初始容量来决定容量和阈值的初始值。</li></ol></li><li>根据新容量和旧容量的关系，以及是否需要扩容来决定新阈值的值。</li><li>创建一个新的哈希数组，并将旧哈希数组中的元素复制到新哈希数组中，以完成初始化或扩容操作。</li></ol><h2 id="数据迁移" tabindex="-1"><a class="header-anchor" href="#数据迁移"><span>数据迁移</span></a></h2><p>链表：将各个元素的hash值与旧的容量进行&amp;运算，如果为0，则位置不变；如果为1，迁移到原位置+扩容位数</p><h2 id="扰动函数" tabindex="-1"><a class="header-anchor" href="#扰动函数"><span>扰动函数</span></a></h2><p>用于优化散列效果</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p><h2 id="初始化容量" tabindex="-1"><a class="header-anchor" href="#初始化容量"><span>初始化容量</span></a></h2><p>在没有设置初始化容量时，在put时会通过扩容函数resize函数进行初始化，初始化容量为16. 设置了初始化容量，会根据tableSizeFor计算出最接近的容量进行设置，如17-&gt;32.</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tableSizeFor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cap) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MAXIMUM_CAPACITY) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MAXIMUM_CAPACITY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了把二进制的各个位置都填上1，当二进制的各个位置都是1以后，就是一个标准的2的倍数减1了，最后把结果加 1 再返回即可。</p><h2 id="负载因子" tabindex="-1"><a class="header-anchor" href="#负载因子"><span>负载因子</span></a></h2><p>0.75 是一个默认构造值，在创建 HashMap 也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</p><h2 id="链表树化" tabindex="-1"><a class="header-anchor" href="#链表树化"><span>链表树化</span></a></h2><p>条件：链表长度大于等于8；数组容量大于64。否则只是扩容，不会树化。 过程：先将链表节点转换为树节点，同时记录链表的顺序。方便后续树转链表和拆分。 进行红黑树转换</p><h2 id="红黑树转链" tabindex="-1"><a class="header-anchor" href="#红黑树转链"><span>红黑树转链</span></a></h2><p>在链表树化过程中记录了链表顺序，所以只需要将树节点转换为链表节点。</p>`,27),e=[n];function t(k,p){return a(),s("div",null,e)}const g=i(h,[["render",t],["__file","HashMap.html.vue"]]),E=JSON.parse('{"path":"/technology/java/HashMap.html","title":"HashMap","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[]},{"level":2,"title":"put流程","slug":"put流程","link":"#put流程","children":[]},{"level":2,"title":"get流程","slug":"get流程","link":"#get流程","children":[]},{"level":2,"title":"remove流程","slug":"remove流程","link":"#remove流程","children":[]},{"level":2,"title":"扩容实现流程","slug":"扩容实现流程","link":"#扩容实现流程","children":[]},{"level":2,"title":"数据迁移","slug":"数据迁移","link":"#数据迁移","children":[]},{"level":2,"title":"扰动函数","slug":"扰动函数","link":"#扰动函数","children":[]},{"level":2,"title":"初始化容量","slug":"初始化容量","link":"#初始化容量","children":[]},{"level":2,"title":"负载因子","slug":"负载因子","link":"#负载因子","children":[]},{"level":2,"title":"链表树化","slug":"链表树化","link":"#链表树化","children":[]},{"level":2,"title":"红黑树转链","slug":"红黑树转链","link":"#红黑树转链","children":[]}],"git":{"createdTime":1717684132000,"updatedTime":1717684132000,"contributors":[{"name":"周宇杰","email":"1348562017@qq.com","commits":1}]},"readingTime":{"minutes":4.32,"words":1295},"filePathRelative":"technology/java/HashMap.md","localizedDate":"June 6, 2024","excerpt":"\\n<h2>数据结构</h2>\\n<p>HashMap的数据结构为Node数组+Node链表+TreeNode红黑树。他的整体结构是一个Node数组，在数组的每个位置是一个链表。当链表的长度&gt;=8或数组容量&gt;=64时，链表会转换成红黑树。\\nNode对象包含4个元素（hash、key、value、next）\\nTreeNode对象包含5个元素（parent、left、right、prev、red）</p>\\n<h2>put流程</h2>\\n<ol>\\n<li>根据给定的哈希值和键值对，计算出该元素应当插入的哈希槽。</li>\\n<li>如果哈希数组未初始化或容量不足，则需要先初始化或扩容哈希数组。</li>\\n<li>在哈希槽中查找是否存在与新元素同位的元素（即哈希值和键都相同的元素）。</li>\\n<li>如果不存在同位元素，则将新元素插入到哈希槽中。</li>\\n<li>如果存在同位元素：\\n<ol>\\n<li>如果需要维持原状（即不覆盖旧值），则返回同位元素的旧值。</li>\\n<li>如果不需要维持原状，或者旧值为null，则更新同位元素的值为新值，并返回旧值。</li>\\n</ol>\\n</li>\\n<li>如果插入新元素后，哈希数组的容量超过了阈值，则需要对哈希数组进行扩容。</li>\\n<li>返回同位元素的旧值，如果不存在同位元素，则返回null。</li>\\n</ol>"}');export{g as comp,E as data};
