import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as c,a as d}from"./app-ZK3Ibs3L.js";const l={},a=d('<h1 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制"><span>垃圾回收机制</span></a></h1><p><strong>内存泄漏</strong>指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。</p><h2 id="方法区的回收" tabindex="-1"><a class="header-anchor" href="#方法区的回收"><span>方法区的回收</span></a></h2><p>方法区中能回收的内容主要就是不再使用的类。</p><p>判定一个类可以被卸载。需要同时满足下面三个条件：</p><ol><li>此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。</li><li>加载该类的类加载器已经被回收。</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用。</li></ol><h2 id="堆回收" tabindex="-1"><a class="header-anchor" href="#堆回收"><span>堆回收</span></a></h2><p><code>Java</code>中的对象是否能被回收，是根据对象是否被<mark>引用</mark>来决定的，即能否通过栈内存中的引用访问到实例对象。</p><p>常见判断方法：引用计数器、可达性分析法</p><h3 id="引用计数器" tabindex="-1"><a class="header-anchor" href="#引用计数器"><span>引用计数器</span></a></h3><p>引用计数器会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1 。</p><p>优点：实现简单</p><p>缺点：</p><ol><li>每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响。</li><li>存在循环引用问题，所谓循环引用就是当<code>A</code>引用<code>B</code>，<code>B</code>同时引用<code>A</code>时会出现对象无法回收的问题。</li></ol><h3 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法"><span>可达性分析算法</span></a></h3><p>可达性分析将对象分为两类：垃圾回收的根对象（<code>GCRoot</code>）和普通对象，对象与对象之间存在引用关系。</p><p>可达性分析算法指如果某个到<code>GC Root</code>对象是科大的，对象就不可被回收。</p><blockquote><p><strong><code>GCRoot</code>对象：</strong></p><ul><li>线程<code>Thread</code>对象，引用线程栈帧中的方法参数、局部变量等。</li><li>系统类加载器加载的<code>java.lang.Class</code>对象，引用类中的静态变量。</li><li>监视器对象，用来保存同步锁<code>synchronized</code>关键字持有的对象。</li><li>本地方法调用时使用的全局对象。</li></ul></blockquote><h3 id="对象引用" tabindex="-1"><a class="header-anchor" href="#对象引用"><span>对象引用</span></a></h3><p>可达性算法中描述的对象引用，一般指的是强引用，即是<code>GCRoot</code>对象对普通对象有引用关系，这要这层关系存在，普通对象就不会被回收。</p><blockquote><p>**对象引用方式：**强引用、软引用、弱引用、虚引用、终结器引用</p></blockquote><h4 id="软引用" tabindex="-1"><a class="header-anchor" href="#软引用"><span>软引用</span></a></h4><p>如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。</p><p>在<code>JDK 1.2</code>之后提供了<code>SoftReference</code>类来实现软引用，软引用常用于缓存中。</p><blockquote><p><strong>软引用执行流程</strong></p><ul><li>将对象使用软引用包装起来，<code>new SoftReference&lt;对象类型&gt;(对象)</code>。</li><li>内存不足时，虚拟机尝试进行垃圾回收。</li><li>如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。</li><li>如果内存依然不足，抛出<code>OutOfMemory</code>异常。</li></ul></blockquote><p><code>SoftReference</code>提供了一套队列机制：</p><ul><li>软引用创建时，通过构造器传入引用队列</li><li>在软引用中包含的对象被回收时，该软引用对象会被放入引用队列</li><li>通过代码遍历引用队列，将<code>SoftReference</code>的强引用删除</li></ul><h4 id="弱引用" tabindex="-1"><a class="header-anchor" href="#弱引用"><span>弱引用</span></a></h4><p>弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。</p><p>在<code>JDK 1.2</code>之后提供了<code>WeakReference</code>类来实现弱引用，弱引用主要在<code>ThreadLoacl</code>中使用。</p><p>弱引用对象本身也可以使用引用队列进行回收。</p><h4 id="虚引用和终结器引用" tabindex="-1"><a class="header-anchor" href="#虚引用和终结器引用"><span>虚引用和终结器引用</span></a></h4><p><mark>在常规开发中不会使用。</mark></p><p><strong>虚引用</strong>也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是在当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用<code>PhantomReference</code>实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</p><p><strong>终结器</strong>引用指的是在对象需要被回收时，对象将会被放置在<code>Finalizer</code>类中的引用队列中，并在稍后由一条由<code>FinalizeThread</code>线程从队列中获取对象，然后执行对象的<code>finalize</code>方法。在这个过程中可以在<code>finalize</code>方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。</p><h3 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h3><p>垃圾回收要做两件事：</p><ol><li>找到内存中存活的对象</li><li>释放不再存活对象的内存，使得程序能再次利用这部分空间</li></ol><p><code>Java</code>垃圾回收过程会通过单独的<code>GC</code>线程来完成，但是不管使用哪一种<code>GC</code>算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为<code>Stop The World</code>简称<code>STW</code>，人如果STW时间过长则会影响用户的使用。</p><h4 id="评价标准" tabindex="-1"><a class="header-anchor" href="#评价标准"><span>评价标准</span></a></h4><ol><li>吞吐量</li></ol><p>吞吐量指的是<code>CPU</code>用来执行用户代码的时间与CPU总执行时间的比值，即吞吐量=执行用户代码时间/（执行用户代码时间 + <code>GC</code>时间）。吞吐量数值越高，垃圾回收的效率就越高。</p><ol start="2"><li>最大暂停时间</li></ol><p>最大暂停时间指的是所有再垃圾回收过程中的STW时间最大值。最大暂停时间越短，用户使用系统时受到的影响就越短。</p><ol start="3"><li>堆使用效率</li></ol><p>不同的垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清楚算法要优于复制算法。</p><h4 id="标记清除算法" tabindex="-1"><a class="header-anchor" href="#标记清除算法"><span>标记清除算法</span></a></h4><p>核心思想分为两个阶段：</p><ol><li>标记阶段：将所有存活的对象进行标记。<code>Java</code>中使用可达性分析算法，从<code>GCRoot</code>开始通过引用链遍历出所有存活对象。</li><li>清除阶段：从内存中删除没有被标记也就是非存活对象。</li></ol><blockquote><p>优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</p><p>缺点：</p><ol><li>碎片化问题</li></ol><p>由于内存是连续的，所以在对象被删除之后，内存中会出现很多的细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。</p><ol start="2"><li>分配速度慢</li></ol><p>由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。</p></blockquote><h4 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法"><span>复制算法</span></a></h4><p>核心思想：</p><ol><li>准备两块空间<code>From</code>空间和<code>To</code>空间，每次在对象分配阶段，只能使用其中一块空间（<code>From</code>空间）。</li><li>在垃圾回收<code>GC</code>阶段，将<code>From</code>中存活对象复制到<code>To</code>空间。</li><li>将两块空间的<code>From</code>和<code>To</code>名字互换。</li><li>回收<code>To</code>空间中的对象</li></ol><blockquote><p>优缺点：吞吐量高、不会发生碎片化、内存使用效率低</p></blockquote><h4 id="标记整理算法" tabindex="-1"><a class="header-anchor" href="#标记整理算法"><span>标记整理算法</span></a></h4><p>核心思想：</p><ol><li>标记阶段：将所有存活的对象进行标记。<code>Java</code>中使用可达性分析算法，从<code>GCRoot</code>开始通过引用链遍历出所有存活对象。</li><li>整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。</li></ol><blockquote><p>优缺点：内存使用效率高、不会发生碎片化、整理阶段的效率不高</p></blockquote><h4 id="分代垃圾回收算法⭐" tabindex="-1"><a class="header-anchor" href="#分代垃圾回收算法⭐"><span>分代垃圾回收算法⭐</span></a></h4><p>分代垃圾回收会将整个区域划分为年轻代（存放存活时间比较短的对象）和老年代（存放存活时间比较长的对象）。</p><p>年轻代包含<code>Eden</code>、<code>S0（Form）</code>、<code>S1（To）</code>区。</p><p>分代回收时，创建出来的对象，首先会被放入<code>Eden</code>伊甸园区。</p><p>随着对象在Eden区越来越多，如果<code>Eden</code>区满，新创建的对象已经无法放入，就会触发年轻代的<code>GC</code>，称为<code>MinorGC</code>或者<code>YoungGC</code>。</p><p><code>MinorGC</code>会把需要<code>Eden</code>中和<code>From</code>选哟回收的对象回收，把没有回收的对象放入<code>To</code>区。</p><p>每次<code>MinorGC</code>都会为对象记录他的年龄，初始值为0，每次<code>GC</code>完加1。</p><p>如果<code>MinorGC</code>后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。</p><p>当老年代中空间不足，无法放入新的对象时，先尝试<code>MinorGC</code>如果还是不足，就会触发<code>FullGC</code>，<code>FullGC</code>会对整个堆进行垃圾回收。</p><blockquote><p><strong>为什么分代GC算法要把堆分成年轻代和老年代？</strong></p><ul><li>系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。</li><li>老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。</li><li>在虚拟机的默认设置中，新生代大小要远小于老年代的大小。</li></ul><p><strong>主要原因</strong></p><ol><li>可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。</li><li>新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记清除和标记整理算法，由程序员来选择灵活度较高。</li><li>分代的设计中允许只回收新生代（<code>MinorGC</code>），如果能满足对象分配的要求就不需要对整个堆进行回收（<code>FullGC</code>），STW时间就会减少。</li></ol></blockquote><h3 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器"><span>垃圾回收器</span></a></h3><h4 id="年轻代——serial垃圾回收器" tabindex="-1"><a class="header-anchor" href="#年轻代——serial垃圾回收器"><span>年轻代——Serial垃圾回收器</span></a></h4><p><code>Serial</code>是一种单线程串行回收年轻代的垃圾回收器。</p><p><strong>回收年代：</strong> 年轻代</p><p><strong>回收算法：</strong> 复制算法</p><p><strong>优点：</strong> 单CPU处理器下吞吐量非常出色</p><p><strong>缺点：</strong> 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</p><p><strong>适用场景：</strong><code>Java</code>编写的客户端程序或者硬件配置有限的场景</p><h4 id="老年代——serialold垃圾回收器" tabindex="-1"><a class="header-anchor" href="#老年代——serialold垃圾回收器"><span>老年代——SerialOld垃圾回收器</span></a></h4><p><code>SerialOld</code>是<code>Serial</code>垃圾回收器的老年代版本，采用单线程串行回收。</p><p><strong>回收年代：</strong> 老年代</p><p><strong>回收算法：</strong> 标记整理算法</p><p><strong>优点：</strong> 单<code>CPU</code>处理器下吞吐量非常出色</p><p><strong>缺点：</strong> 多<code>CPU</code>下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</p><p><strong>适用场景：</strong> 与<code>Serial</code>垃圾回收器搭配使用，或者在<code>CMS</code>特殊情况下使用</p><h4 id="年轻代——parnew垃圾回收器" tabindex="-1"><a class="header-anchor" href="#年轻代——parnew垃圾回收器"><span>年轻代——ParNew垃圾回收器</span></a></h4><p><code>ParNew</code>垃圾回收器本质上是对<code>Serial</code>在多<code>CPU</code>下的优化，使用多线程进行垃圾回收。</p><p><strong>回收年代：</strong> 年轻代</p><p><strong>回收算法：</strong> 复制算法</p><p><strong>优点：</strong> 多<code>CPU</code>处理器下停顿时间较短</p><p><strong>缺点：</strong> 吞吐量和停顿时间不如<code>G1</code>，所以在<code>JDK9</code>之后不建议使用</p><p><strong>使用场景：</strong><code>JDK8</code>及之前的版本中，与<code>CMS</code>老年代垃圾回收器搭配使用</p><h4 id="老年代——cms-concurrent-mark-sweep-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#老年代——cms-concurrent-mark-sweep-垃圾回收器"><span>老年代——CMS（Concurrent Mark Sweep）垃圾回收器</span></a></h4><p>CMS垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行每减少了用户线程的等待时间。</p><p><strong>回收年代：</strong> 老年代</p><p><strong>回收算法：</strong> 标记清除算法</p><p><strong>优点：</strong> 系统由于垃圾回收出现的停顿时间较短，用户体验好</p><p><strong>缺点：</strong> 内存碎片化问题、退化问题、浮动垃圾问题</p><p><strong>使用场景：</strong> 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等</p><blockquote><p>CMS执行步骤</p><ol><li>初始标记，用极短的时间标记出<code>GCRoot</code>能直接关联到的对象。</li><li>并发标记，标记所有的对象，用户线程不需要暂停。</li><li>重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。</li><li>并发清理，清理死亡的对象，用户线程不需要暂停。</li></ol></blockquote><h4 id="年轻代——parallel-scavenge垃圾回收器" tabindex="-1"><a class="header-anchor" href="#年轻代——parallel-scavenge垃圾回收器"><span>年轻代——Parallel Scavenge垃圾回收器</span></a></h4><p><code>Parallel Scavenge</code>是<code>JDK8</code>默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。具备<mark>自动调整堆内存大小</mark>的特点。</p><p><strong>回收年代：</strong> 年轻代</p><p><strong>回收算法：</strong> 复制算法</p><p><strong>优点：</strong> 吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数</p><p><strong>缺点：</strong> 不能保证单次的停顿时间</p><p><strong>适用场景：</strong> 后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出</p><h4 id="老年代——parallel-old垃圾回收器" tabindex="-1"><a class="header-anchor" href="#老年代——parallel-old垃圾回收器"><span>老年代——Parallel Old垃圾回收器</span></a></h4><p><code>Parallel Old</code>是为<code>Parallel Scavenge</code>收集器设计的老年代版本，利用多线程并发收集。</p><p><strong>回收年代：</strong> 老年代</p><p><strong>回收算法：</strong> 标记整理算法</p><p><strong>优点：</strong> 并发收集，在多核<code>CPU</code>下效率较高</p><p><strong>缺点：</strong> 暂停时间会比较长</p><p><strong>适用场景：</strong> 与<code>Parallel Scavenge</code>配套使用</p><h4 id="g1垃圾回收器" tabindex="-1"><a class="header-anchor" href="#g1垃圾回收器"><span>G1垃圾回收器</span></a></h4><p><strong>回收年代：</strong> 年轻代+老年代</p><p><strong>回收算法：</strong> 复制算法</p><p><strong>优点：</strong> 对比较大的堆如超过6G的堆回收时，延迟可控，不会产生内存碎片，并发标记的<code>SATB</code>算法效率高</p><p><strong>缺点：</strong><code>JDK8</code>之前还不够成熟</p><p><strong>适用场景：</strong><code>JDK8</code>最新版本、<code>JDK9</code>之后建议默认使用</p><p><code>JDK9</code>之后默认的垃圾回收器是G1（<code>Garbage First</code>）垃圾回收器，将<code>Parallel Scavenge</code>与<code>CMS</code>的优点融合。</p><p>支持巨大的堆空间回收，并有较高的吞吐量；支持多<code>CPU</code>并行垃圾回收；允许用户设置最大暂停时间。</p><p><code>G1</code>的整个堆会被划分成多个大小相等的区域，称之为区<code>Region</code>，区域不要求是连续的，分为<code>Eden</code>、<code>Survivor</code>、<code>Old</code>区。<code>Region</code>的大小通过堆空间大小/2048计算得到，<code>Region size</code>必须是2的指数幂，取值范围从1M到32M。</p><p>垃圾回收方式：年轻代回收（<code>Young GC</code>）、混合回收（<code>Mixed GC</code>）</p><p>年轻代回收：回收<code>Eden</code>区和<code>Survivor</code>区中不用的对象，会导致<code>STW</code>。</p><blockquote><p><strong>执行流程</strong></p><ol><li>新创建的对象会存放在Eden区。当<code>G1</code>判断年轻代区不足（<code>max</code>默认60%），无法分配对象时需要回收时会执行<code>Young GC</code>。</li><li>标记出<code>Eden</code>和<code>Survivor</code>区域中的存活对象。</li><li>根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的<code>Survivor</code>区中（年龄+1），清空这些区域。</li><li>后续<code>Young GC</code>时与之前相同，只不过<code>Survivor</code>区中存活对象会被搬运到另一个<code>Survivor</code>区。</li><li>当某个存活对象的年龄达到阈值（默认15），会被放入老年代。</li><li>部分对象如果大小超过<code>Region</code>的一半，会直接放入老年代，这类老年代被称为<code>Humongous</code>区。</li><li>多次回收过后，会出现很多<code>Old</code>老年代区，此时总堆占有率达到阈值时会触发混合回收<code>MixedGC</code>。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。</li></ol></blockquote><p>G1在进行<code>Young GC</code>的过程中会去记录每次垃圾回收时每个<code>Eden</code>区和<code>Survivor</code>区的平均耗时，以作为下次回收时的参考依据。</p><p>混合回收分为：初始标记、并发标记、最终标记、并发清理</p><p><code>G1</code>对老年代的清理会选择存活度最低的区域来进行回收，这个可以保证回收效率最高，这也是<code>G1</code>名称的由来。</p><div class="hint-container caution"><p class="hint-container-title">Caution</p><p>如果清理过程中发现没有足够的空<code>Region</code>存放转移的对象，会出现<code>FullGC</code>。单线程执行标记整理算法，此时会导致用户线程的暂停。所以尽量保证该应用的堆内存有一定多余的空间。</p></div>',128),n=[a];function r(p,i){return c(),o("div",null,n)}const h=e(l,[["render",r],["__file","垃圾回收机制.html.vue"]]),g=JSON.parse('{"path":"/technology/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html","title":"垃圾回收机制","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"方法区的回收","slug":"方法区的回收","link":"#方法区的回收","children":[]},{"level":2,"title":"堆回收","slug":"堆回收","link":"#堆回收","children":[{"level":3,"title":"引用计数器","slug":"引用计数器","link":"#引用计数器","children":[]},{"level":3,"title":"可达性分析算法","slug":"可达性分析算法","link":"#可达性分析算法","children":[]},{"level":3,"title":"对象引用","slug":"对象引用","link":"#对象引用","children":[]},{"level":3,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[]},{"level":3,"title":"垃圾回收器","slug":"垃圾回收器","link":"#垃圾回收器","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":13.75,"words":4125},"filePathRelative":"technology/jvm/垃圾回收机制.md","excerpt":"\\n<p><strong>内存泄漏</strong>指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。</p>\\n<h2>方法区的回收</h2>\\n<p>方法区中能回收的内容主要就是不再使用的类。</p>\\n<p>判定一个类可以被卸载。需要同时满足下面三个条件：</p>\\n<ol>\\n<li>此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。</li>\\n<li>加载该类的类加载器已经被回收。</li>\\n<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用。</li>\\n</ol>\\n<h2>堆回收</h2>\\n<p><code>Java</code>中的对象是否能被回收，是根据对象是否被<mark>引用</mark>来决定的，即能否通过栈内存中的引用访问到实例对象。</p>"}');export{h as comp,g as data};
