import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,c as l,b as n,d as o,w as t,a,o as d,e as p}from"./app-ZK3Ibs3L.js";const h={},c=a(`<h1 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h1><h2 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期"><span>类的生命周期</span></a></h2><p><strong>概述</strong></p><p>类的生命周期描述了一个类加载、使用、卸载的整个过程</p><p>加载 →连接→初始化→使用→卸载</p><p>连接：验证→准备→解析</p><h3 id="加载阶段-loading" tabindex="-1"><a class="header-anchor" href="#加载阶段-loading"><span>加载阶段（Loading）</span></a></h3><ol><li><p><strong>类加载器</strong>根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。</p></li><li><p><strong>类加载器</strong>在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中。</p></li><li><p><strong>类加载器</strong>在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。 在方法区中生成一个<code>InstanceKlass</code>对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。</p></li><li><p>同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的<code>java.lang.Class</code>对象。</p><p>作用是在Java代码中去获取类的信息以及存储静态字段的数据（ JDK 8及以后）。</p></li></ol><blockquote><p>对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。</p><p>这样Java虚拟机就能很好地控制开发者访问数据的范围。</p></blockquote><h3 id="连接阶段-linking" tabindex="-1"><a class="header-anchor" href="#连接阶段-linking"><span>连接阶段（Linking）</span></a></h3><p><strong>包含</strong></p><p>验证：验证内容是否满足《Java虚拟机规范》</p><p>准备：给静态变量赋初值</p><p>解析：将常量池中的符号引用替换成指向内存的直接引用</p><hr><h4 id="连接阶段——验证" tabindex="-1"><a class="header-anchor" href="#连接阶段——验证"><span>连接阶段——验证</span></a></h4><p>目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。<mark>这个阶段一般不需要程序员参与</mark></p><p>主要包含如下四个部分：</p><ol><li>文件格式验证，比如文件是否以<code>0xCAFEBABE</code>开头，主次版本号是否满足当前Java虚拟机版本要求</li><li>元信息验证，例如类必须有父类（<code>super</code>不能为空）</li><li>验证程序指向指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去</li><li>符号引用验证，例如是否访问了其他类中<code>private</code>的方法等</li></ol><h4 id="连接阶段——准备" tabindex="-1"><a class="header-anchor" href="#连接阶段——准备"><span>连接阶段——准备</span></a></h4><ol><li>为静态变量（<code>static</code>）分配内存并设置初始值</li><li><code>final</code>修饰的基本数据类型的静态变量，直接会将代码中的值进行赋值</li></ol><h4 id="连接阶段——解析" tabindex="-1"><a class="header-anchor" href="#连接阶段——解析"><span>连接阶段——解析</span></a></h4><p>主要是将常量池中的符号引用<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>替换为直接引用<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。</p><h3 id="初始化阶段" tabindex="-1"><a class="header-anchor" href="#初始化阶段"><span>初始化阶段</span></a></h3><p>初始化阶段会执行静态代码块中的代码，并为静态变量赋值。</p><p>初始化阶段会执行字节码文件中<code>clinit</code>部分的字节码指令。</p><blockquote><p><strong>以下几种方式会导致类的初始化：</strong></p><ol><li>访问一个类的静态变量或者静态方法，注意变量是<code>final</code>修饰的并且等号右边是不会触发初始化。</li><li>调用<code>Class.forName(String className)</code>。</li><li><code>new</code>一个该类的对象时。</li><li>执行<code>Main</code>方法的当前类。</li></ol></blockquote><blockquote><p><strong><code>clinit</code>指令在特定情况下不会出现：</strong></p><ol><li>无静态代码块且无静态变量赋值语句。</li><li>有静态变量的声明，但是没有赋值语句。</li><li>静态变量的定义使用<code>final</code>关键字，这类变量会在准备阶段直接进行初始化。</li></ol></blockquote><p>直接访问父类的静态变量，不会触发子类的初始化。</p><p>子类的初始化<code>clinit</code>调用之前，会先调用父类的<code>clinit</code>初始化方法。</p><p>数组的创建不会导致数组中元素的类进行初始化。</p><h2 id="类加载器-classloader" tabindex="-1"><a class="header-anchor" href="#类加载器-classloader"><span>类加载器（ClassLoader）</span></a></h2><p>类加载器是<code>Java</code>虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。</p><p>类加载器只参与加载过程中的字节码获取并加载到内存这一部分。</p><p>作用：负责类加载过程中字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换成byte[]，接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。</p><h3 id="类加载器的分类" tabindex="-1"><a class="header-anchor" href="#类加载器的分类"><span>类加载器的分类</span></a></h3><p>类加载器分为两类，一类是<code>Java</code>代码实现的，一类是<code>Java</code>虚拟机底层源码实现的。</p><h4 id="虚拟机底层实现" tabindex="-1"><a class="header-anchor" href="#虚拟机底层实现"><span>虚拟机底层实现</span></a></h4><p>启动类加载器（<code>Bootstrap</code>）——加载<code>Java</code>中最核心的类（C++，JDK8）</p><p>启动类加载器（<code>BootClassLoader</code>）（Java，JDK9）——继承自<code>BuiltinClassLoader</code>实现从模块中找到要加载的字节码资源文件，==启动类加载器依然无法通过<code>Java</code>代码获取到，返回的仍然是null，保持了统一。</p><h4 id="java代码实现" tabindex="-1"><a class="header-anchor" href="#java代码实现"><span>Java代码实现</span></a></h4><p>扩展类加载器（<code>Extension</code>）——允许拓展<code>Java</code>中比较通用的类，继承自<code>URLClassLoader</code>（JDK8）</p><p>平台类加载器（<code>PlatformClassLoader</code>）——继承自<code>BuiltinClassLoader</code>。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。（JDK9）</p><p>应用类加载器（<code>Application</code>）——加载应用使用的类（JDK8与JDK9，继承关系发生变化）</p><h3 id="双亲委派机制⭐" tabindex="-1"><a class="header-anchor" href="#双亲委派机制⭐"><span>双亲委派机制⭐</span></a></h3><p>双亲委派机制的核心是解决一个类到底由谁加载的问题。</p><p><strong>作用：</strong></p><ol><li>保证类加载的安全性——避免恶意代码替换<code>JDK</code>中的核心库</li><li>避免重复加载——避免同一个类被多次加载</li></ol><blockquote><p><strong>概念：</strong> 当一个类加载器接收到加载类的任务时，会<mark>自底向上查找是否加载过，再由顶向下进行加载</mark>。</p></blockquote><p>每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。</p><p>如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。</p><p>第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回。</p><p>向下委派加载起到了一个加载优先级的作用。</p><h3 id="打破双亲委派机制⭐" tabindex="-1"><a class="header-anchor" href="#打破双亲委派机制⭐"><span>打破双亲委派机制⭐</span></a></h3><p><strong>方式：</strong></p><ol><li>自定义类加载器——自定义类加载器并且重写<code>loadClass</code>方法，就可以将双亲委派机制的代码去除；<code>Tomcat</code>通过这种方式实现应用之间类隔离</li><li>线程上下文类加载器——利用上下文类加载器加载类，比如<code>JDBC</code>和<code>JNDI</code>等，使用SPI机制+线程上下文加载器，通过<code>Thread.currentThread().getContextClassLoader()</code>获取应用类加载器——<mark>没有打破</mark></li><li><code>Osgi</code>框架的类加载器——历史上<code>Osgi</code>框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载</li></ol><h4 id="自定义类加载器" tabindex="-1"><a class="header-anchor" href="#自定义类加载器"><span>自定义类加载器</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//类加载的入口，提供了双亲委托机制。内部会调用findClass</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String name)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//由类加载器子类实现，获取二进制数据调用defineClass，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String name)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String name,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] b,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行类生命周期中的连接阶段</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolveClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正确的去实现一个自定义类加载器的方式是重写<code>findClass</code>方法，这样不会破坏双亲委派机制。</p>`,59),r=a('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>符号引用就是在字节码文件中使用编号来访问常量池中的内容 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>直接引用就是不在使用编号来访问内容，而是使用内存中的地址进行访问具体的数据 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li></ol></section>',2);function k(g,f){const s=e("RouteLink");return d(),l("div",null,[c,n("p",null,[o(s,{to:"/technology/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6.html"},{default:t(()=>[p("源码解析")]),_:1})]),r])}const m=i(h,[["render",k],["__file","类加载器.html.vue"]]),u=JSON.parse('{"path":"/technology/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html","title":"类加载器","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"类的生命周期","slug":"类的生命周期","link":"#类的生命周期","children":[{"level":3,"title":"加载阶段（Loading）","slug":"加载阶段-loading","link":"#加载阶段-loading","children":[]},{"level":3,"title":"连接阶段（Linking）","slug":"连接阶段-linking","link":"#连接阶段-linking","children":[]},{"level":3,"title":"初始化阶段","slug":"初始化阶段","link":"#初始化阶段","children":[]}]},{"level":2,"title":"类加载器（ClassLoader）","slug":"类加载器-classloader","link":"#类加载器-classloader","children":[{"level":3,"title":"类加载器的分类","slug":"类加载器的分类","link":"#类加载器的分类","children":[]},{"level":3,"title":"双亲委派机制⭐","slug":"双亲委派机制⭐","link":"#双亲委派机制⭐","children":[]},{"level":3,"title":"打破双亲委派机制⭐","slug":"打破双亲委派机制⭐","link":"#打破双亲委派机制⭐","children":[]}]}],"git":{"createdTime":1717764142000,"updatedTime":1717764142000,"contributors":[{"name":"周宇杰","email":"1348562017@qq.com","commits":1}]},"readingTime":{"minutes":6.56,"words":1969},"filePathRelative":"technology/jvm/类加载器.md","localizedDate":"June 7, 2024","excerpt":"\\n<h2>类的生命周期</h2>\\n<p><strong>概述</strong></p>\\n<p>类的生命周期描述了一个类加载、使用、卸载的整个过程</p>\\n<p>加载 →连接→初始化→使用→卸载</p>\\n<p>连接：验证→准备→解析</p>\\n<h3>加载阶段（Loading）</h3>\\n<ol>\\n<li>\\n<p><strong>类加载器</strong>根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。</p>\\n</li>\\n<li>\\n<p><strong>类加载器</strong>在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中。</p>\\n</li>\\n<li>\\n<p><strong>类加载器</strong>在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。\\n在方法区中生成一个<code>InstanceKlass</code>对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。</p>\\n</li>\\n<li>\\n<p>同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的<code>java.lang.Class</code>对象。</p>\\n<p>作用是在Java代码中去获取类的信息以及存储静态字段的数据（ JDK 8及以后）。</p>\\n</li>\\n</ol>"}');export{m as comp,u as data};
