import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as n,a as l}from"./app-ZK3Ibs3L.js";const i={},r=l('<h1 id="java锁" tabindex="-1"><a class="header-anchor" href="#java锁"><span>Java锁</span></a></h1><h2 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile"><span>volatile</span></a></h2><p>volatile关键字是Java虚拟机提供的最轻量级的同步机制，作为修饰符出现，用来修饰变量，来确保变量对所有线程的可见性。<br>会在JMM中通过添加lock指令来保证：</p><ol><li>将本处理器的缓存写入内存；</li><li>重排序时不能把后面的指令重排序到内存屏障之前的位置；</li><li>如果是写入动作会导致其他处理器中对应的内存无效。</li></ol><p>volatile不能解决原子性，防止指令重排序。</p><h2 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized"><span>synchronized</span></a></h2><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><h4 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性"><span>原子性</span></a></h4><p>一个操作是不可中断的，要么全部执行成功要么全部执行失败。</p><h4 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性"><span>可见性</span></a></h4><ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时从主内存中重新读取最新的值。</li><li>volatile的可见性都是通过内存屏障来实现的。</li><li>synchronized靠操作系统内存互斥锁实现，相当于JMM中的lock、unlock。退出代码块时刷新变量到主内存。</li></ol><h4 id="有序性" tabindex="-1"><a class="header-anchor" href="#有序性"><span>有序性</span></a></h4><p><code>as-if-serial</code>：保证不管编译器和处理器为了性能优化会如何进行指令重排序，都需要保证单线程下的运行结果的正确性。<strong>即如果在本线程内观察，所有操作都是有序的；如果在一个线程观察另一个线程，所有操作都是无序的。</strong></p><h4 id="可重入性" tabindex="-1"><a class="header-anchor" href="#可重入性"><span>可重入性</span></a></h4><p>允许一个线程二次请求自己持有对象锁的临界资源。<br>之所以是可以重入。是因为synchronized 锁对象有个计数器，会随着线程获取锁+1计数，当线程执行完毕后-1，直到清零释放锁。</p><h2 id="reentrantlock" tabindex="-1"><a class="header-anchor" href="#reentrantlock"><span>ReentrantLock</span></a></h2><p>ReentrantLock 是基于 Lock 实现的<strong>可重入锁</strong>，所有的 Lock 都是基于 <strong>AQS</strong> 实 现的，AQS 和 Condition 各自维护不同的对象，在使用 Lock 和 Condition 时，其实就是两个队列的互相移动。它所提供的共享锁、互斥锁都是基于对 <strong>state</strong> 的操作。而它的可重入是因为实现了<strong>同步器 Sync</strong>，在 Sync 的两个实现类中， 包括了公平锁和非公平锁。</p><h3 id="公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁"><span>公平锁</span></a></h3><p>通过ReentrantLock的构造函数确认在创建时是否初始化公平锁<br>判断公平锁，主要时根据方法<code>tryAcquire</code>中，是否存在<code>!hasQueuedPredecessors()</code><br><code>hasQueuedPredecessors()</code>：判断当前线程是否是同步队列的首位</p><h4 id="公平锁实现" tabindex="-1"><a class="header-anchor" href="#公平锁实现"><span>公平锁实现</span></a></h4><h5 id="clh" tabindex="-1"><a class="header-anchor" href="#clh"><span>CLH</span></a></h5><p>CLH 是一种基于单向链表的高性能、公平的自旋锁。AQS 中的队列是 CLH 变体的虚拟双向队（FIFO），AQS 是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。<br>CLH 队列锁的优点是空间复杂度低，在 SMP（Symmetric Multi-Processor）对称 多处理器结构（一台计算机由多个 CPU 组成，并共享内存和其他资源，所有的 CPU 都可以平等地访问内存、I/O 和外部中断）效果还是不错的。但在 NUMA(Non-Uniform Memory Access) 下效果就不太好了。</p><h5 id="mcs" tabindex="-1"><a class="header-anchor" href="#mcs"><span>MCS</span></a></h5><p>MCS也是一种基于链表的可扩展、高性能、公平的自旋锁，但与 CLH 不同。它是真的有下一个节点 next，添加这个真实节点后，它就可以只在本地变量上自旋， 而 CLH 是前驱节点的属性上自旋。</p><h5 id="ticketlock" tabindex="-1"><a class="header-anchor" href="#ticketlock"><span>TicketLock</span></a></h5><p>TicketLock 就像你去银行、呷哺给你的一个排号卡一样，叫到你号你才能进去。 属于严格的公平性实现，但是多处理器系统上，每个进程/线程占用的处理器都 在读写同一个变量，每次读写操作都需要进行多处理间的缓存同步，非常消耗系 统性能。 <br>代码实现上也比较简单，lock() 中设置拥有者的号牌，并进入自旋比对。unlock() 中使用 CAS 进行解锁操作，并处理移除。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ul><li>ReentrantLock 是基于 Lock 实现的可重入锁。</li><li>ReentrantLock 使用起来更加灵活，可操作性也更大，但一定要在 finally 中释放锁，目的是保证在获取锁之后，最终能够被释放。同时不要将获取锁的过程写在 try 里面。</li><li>公平锁的实现依据不同场景和 SMP、NUMA 的使用，会有不同的优劣效果。在实际的使用中一般默认会选择非公平锁，即使是自旋也是耗费性能的，一般会用在较 少等待的线程中，避免自旋时过长。</li></ul><h2 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs"><span>AQS</span></a></h2>',29),s=[r];function o(t,c){return n(),e("div",null,s)}const p=a(i,[["render",o],["__file","Java锁.html.vue"]]),k=JSON.parse('{"path":"/technology/java/Java%E9%94%81.html","title":"Java锁","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":2,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[{"level":3,"title":"特性","slug":"特性","link":"#特性","children":[]}]},{"level":2,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[{"level":3,"title":"公平锁","slug":"公平锁","link":"#公平锁","children":[]}]},{"level":2,"title":"AQS","slug":"aqs","link":"#aqs","children":[]}],"git":{"createdTime":1717726286000,"updatedTime":1717764142000,"contributors":[{"name":"周宇杰","email":"1348562017@qq.com","commits":2}]},"readingTime":{"minutes":3.93,"words":1179},"filePathRelative":"technology/java/Java锁.md","localizedDate":"June 7, 2024","excerpt":"\\n<h2>volatile</h2>\\n<p>volatile关键字是Java虚拟机提供的最轻量级的同步机制，作为修饰符出现，用来修饰变量，来确保变量对所有线程的可见性。<br>会在JMM中通过添加lock指令来保证：</p>\\n<ol>\\n<li>将本处理器的缓存写入内存；</li>\\n<li>重排序时不能把后面的指令重排序到内存屏障之前的位置；</li>\\n<li>如果是写入动作会导致其他处理器中对应的内存无效。</li>\\n</ol>\\n<p>volatile不能解决原子性，防止指令重排序。</p>\\n<h2>synchronized</h2>\\n<h3>特性</h3>\\n<h4>原子性</h4>\\n<p>一个操作是不可中断的，要么全部执行成功要么全部执行失败。</p>"}');export{p as comp,k as data};
