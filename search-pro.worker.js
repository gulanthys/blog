const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":89,\"nextId\":89,\"documentIds\":{\"0\":\"1\",\"1\":\"1#北京合思汇智信息技术有限公司\",\"2\":\"3\",\"3\":\"3#数据结构\",\"4\":\"3#put流程\",\"5\":\"3#get流程\",\"6\":\"3#remove流程\",\"7\":\"3#扩容实现流程\",\"8\":\"3#数据迁移\",\"9\":\"3#扰动函数\",\"10\":\"3#初始化容量\",\"11\":\"3#负载因子\",\"12\":\"3#链表树化\",\"13\":\"3#红黑树转链\",\"14\":\"4\",\"15\":\"4#volatile\",\"16\":\"4#synchronized\",\"17\":\"4#特性\",\"18\":\"4#原子性\",\"19\":\"4#可见性\",\"20\":\"4#有序性\",\"21\":\"4#可重入性\",\"22\":\"4#reentrantlock\",\"23\":\"4#公平锁\",\"24\":\"4#公平锁实现\",\"25\":\"4#clh\",\"26\":\"4#mcs\",\"27\":\"4#ticketlock\",\"28\":\"4#总结\",\"29\":\"4#aqs\",\"30\":\"5\",\"31\":\"5#方法区的回收\",\"32\":\"5#堆回收\",\"33\":\"5#引用计数器\",\"34\":\"5#可达性分析算法\",\"35\":\"5#对象引用\",\"36\":\"5#软引用\",\"37\":\"5#弱引用\",\"38\":\"5#虚引用和终结器引用\",\"39\":\"5#垃圾回收算法\",\"40\":\"5#评价标准\",\"41\":\"5#标记清除算法\",\"42\":\"5#复制算法\",\"43\":\"5#标记整理算法\",\"44\":\"5#分代垃圾回收算法⭐\",\"45\":\"5#垃圾回收器\",\"46\":\"5#年轻代——serial垃圾回收器\",\"47\":\"5#老年代——serialold垃圾回收器\",\"48\":\"5#年轻代——parnew垃圾回收器\",\"49\":\"5#老年代——cms-concurrent-mark-sweep-垃圾回收器\",\"50\":\"5#年轻代——parallel-scavenge垃圾回收器\",\"51\":\"5#老年代——parallel-old垃圾回收器\",\"52\":\"5#g1垃圾回收器\",\"53\":\"6\",\"54\":\"6#文件组成\",\"55\":\"6#基本信息\",\"56\":\"6#常量池\",\"57\":\"6#字段\",\"58\":\"6#方法\",\"59\":\"7\",\"60\":\"7#类的生命周期\",\"61\":\"7#加载阶段-loading\",\"62\":\"7#连接阶段-linking\",\"63\":\"7#连接阶段——验证\",\"64\":\"7#连接阶段——准备\",\"65\":\"7#连接阶段——解析\",\"66\":\"7#初始化阶段\",\"67\":\"7#类加载器-classloader\",\"68\":\"7#类加载器的分类\",\"69\":\"7#虚拟机底层实现\",\"70\":\"7#java代码实现\",\"71\":\"7#双亲委派机制⭐\",\"72\":\"7#打破双亲委派机制⭐\",\"73\":\"7#自定义类加载器\",\"74\":\"8\",\"75\":\"8#程序计数器-program-counter-register\",\"76\":\"8#java虚拟机栈-java-virtual-machine-stack\",\"77\":\"8#局部变量表\",\"78\":\"8#操作数栈\",\"79\":\"8#帧数据\",\"80\":\"8#本地方法栈\",\"81\":\"8#堆\",\"82\":\"8#方法区-method-area\",\"83\":\"8#直接内存-direct-memory\",\"84\":\"9\",\"85\":\"10\",\"86\":\"11\",\"87\":\"12\",\"88\":\"13\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,13],\"2\":[1],\"3\":[1,17],\"4\":[1,22],\"5\":[1,19],\"6\":[1,17],\"7\":[1,11],\"8\":[1,7],\"9\":[1,24],\"10\":[1,34],\"11\":[1,10],\"12\":[1,10],\"13\":[1,3],\"14\":[1],\"15\":[1,11],\"16\":[1],\"17\":[1],\"18\":[1,3],\"19\":[1,11],\"20\":[1,10],\"21\":[1,9],\"22\":[1,25],\"23\":[1,5],\"24\":[1],\"25\":[1,34],\"26\":[1,13],\"27\":[1,22],\"28\":[1,25],\"29\":[1],\"30\":[1,3],\"31\":[1,10],\"32\":[1,6],\"33\":[1,12],\"34\":[1,20],\"35\":[1,11],\"36\":[1,25],\"37\":[1,8],\"38\":[1,17],\"39\":[1,12],\"40\":[1,22],\"41\":[1,23],\"42\":[1,13],\"43\":[1,12],\"44\":[1,55],\"45\":[1],\"46\":[2,12],\"47\":[2,14],\"48\":[2,14],\"49\":[6,32],\"50\":[3,23],\"51\":[3,16],\"52\":[1,84],\"53\":[1,12],\"54\":[1,5],\"55\":[1,36],\"56\":[1,11],\"57\":[1,1],\"58\":[1,8],\"59\":[1],\"60\":[1,8],\"61\":[3,18],\"62\":[3,8],\"63\":[2,15],\"64\":[2,5],\"65\":[2,5],\"66\":[1,24],\"67\":[3,8],\"68\":[1,4],\"69\":[1,13],\"70\":[1,17],\"71\":[1,23],\"72\":[1,17],\"73\":[1,35],\"74\":[1,3],\"75\":[5,9],\"76\":[6,17],\"77\":[1,17],\"78\":[1,7],\"79\":[1,13],\"80\":[1,7],\"81\":[1,17],\"82\":[4,27],\"83\":[4,21],\"84\":[1,3],\"85\":[1],\"86\":[1],\"87\":[1],\"88\":[1]},\"averageFieldLength\":[1.4044943820224722,15.519816965360079],\"storedFields\":{\"0\":{\"h\":\"面试经历\"},\"1\":{\"h\":\"北京合思汇智信息技术有限公司\",\"t\":[\"岗位：Java后端研发实习\",\"时间：2024.06.05\",\"自我介绍\",\"人防资料管理平台项目难点\",\"JVM\",\"哪个HashMap是线程安全的\",\"HashMap是线程不安全的为什么还要使用\",\"不使用ConcurrentHashMap如何确保HashMap线程安全\",\"Linux的操作有哪些\"]},\"2\":{\"h\":\"HashMap\"},\"3\":{\"h\":\"数据结构\",\"t\":[\"HashMap的数据结构为Node数组+Node链表+TreeNode红黑树。他的整体结构是一个Node数组，在数组的每个位置是一个链表。当链表的长度>=8或数组容量>=64时，链表会转换成红黑树。 Node对象包含4个元素（hash、key、value、next） TreeNode对象包含5个元素（parent、left、right、prev、red）\"]},\"4\":{\"h\":\"put流程\",\"t\":[\"根据给定的哈希值和键值对，计算出该元素应当插入的哈希槽。\",\"如果哈希数组未初始化或容量不足，则需要先初始化或扩容哈希数组。\",\"在哈希槽中查找是否存在与新元素同位的元素（即哈希值和键都相同的元素）。\",\"如果不存在同位元素，则将新元素插入到哈希槽中。\",\"如果存在同位元素： \",\"如果需要维持原状（即不覆盖旧值），则返回同位元素的旧值。\",\"如果不需要维持原状，或者旧值为null，则更新同位元素的值为新值，并返回旧值。\",\"如果插入新元素后，哈希数组的容量超过了阈值，则需要对哈希数组进行扩容。\",\"返回同位元素的旧值，如果不存在同位元素，则返回null。\"]},\"5\":{\"h\":\"get流程\",\"t\":[\"根据key值通过扰动函数计算hash值。\",\"首先判断table是否为空以及其长度是否大于0，以及通过(key计算而来的)hash值计算出的哈希槽位置上的元素是否为空。\",\"如果以上条件都满足，则进一步判断首个元素是否与给定的key和hash值匹配。如果匹配，则返回该元素。\",\"如果首个元素不匹配，则判断其后续元素是否为红黑树节点。如果是，则在红黑树中进行查找。\",\"如果后续元素不是红黑树节点，则遍历哈希槽上的后续元素，直到找到匹配的元素或遍历结束。\",\"如果最终没有找到匹配的元素，则返回null。\"]},\"6\":{\"h\":\"remove流程\",\"t\":[\"根据给定的key和hash查找对应的同位元素。\",\"如果找到了匹配的元素，则根据matchValue参数决定是否需要进一步匹配value。\",\"如果需要匹配value且值不匹配，则不移除元素，直接返回null。\",\"如果匹配成功，则根据节点类型（TreeNode或普通Node）进行相应的移除操作。\",\"更新相关计数器和变量，如modCount和size。\",\"调用afterNodeRemoval()进行后续处理。\",\"返回刚刚移除的节点（如果未找到匹配节点则返回null）。\"]},\"7\":{\"h\":\"扩容实现流程\",\"t\":[\"判断哈希数组是否已经初始化， \",\"如果已经初始化，则根据当前容量和最大容量来决定是否需要扩容；\",\"如果还未初始化，则根据是否指定了初始容量来决定容量和阈值的初始值。\",\"根据新容量和旧容量的关系，以及是否需要扩容来决定新阈值的值。\",\"创建一个新的哈希数组，并将旧哈希数组中的元素复制到新哈希数组中，以完成初始化或扩容操作。\"]},\"8\":{\"h\":\"数据迁移\",\"t\":[\"链表：将各个元素的hash值与旧的容量进行&运算，如果为0，则位置不变；如果为1，迁移到原位置+扩容位数\"]},\"9\":{\"h\":\"扰动函数\",\"t\":[\"用于优化散列效果\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }\",\"把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。\"]},\"10\":{\"h\":\"初始化容量\",\"t\":[\"在没有设置初始化容量时，在put时会通过扩容函数resize函数进行初始化，初始化容量为16. 设置了初始化容量，会根据tableSizeFor计算出最接近的容量进行设置，如17->32.\",\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }\",\"为了把二进制的各个位置都填上1，当二进制的各个位置都是1以后，就是一个标准的2的倍数减1了，最后把结果加 1 再返回即可。\"]},\"11\":{\"h\":\"负载因子\",\"t\":[\"0.75 是一个默认构造值，在创建 HashMap 也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。\"]},\"12\":{\"h\":\"链表树化\",\"t\":[\"条件：链表长度大于等于8；数组容量大于64。否则只是扩容，不会树化。 过程：先将链表节点转换为树节点，同时记录链表的顺序。方便后续树转链表和拆分。 进行红黑树转换\"]},\"13\":{\"h\":\"红黑树转链\",\"t\":[\"在链表树化过程中记录了链表顺序，所以只需要将树节点转换为链表节点。\"]},\"14\":{\"h\":\"Java锁\"},\"15\":{\"h\":\"volatile\",\"t\":[\"volatile关键字是Java虚拟机提供的最轻量级的同步机制，作为修饰符出现，用来修饰变量，来确保变量对所有线程的可见性。会在JMM中通过添加lock指令来保证：\",\"将本处理器的缓存写入内存；\",\"重排序时不能把后面的指令重排序到内存屏障之前的位置；\",\"如果是写入动作会导致其他处理器中对应的内存无效。\",\"volatile不能解决原子性，防止指令重排序。\"]},\"16\":{\"h\":\"synchronized\"},\"17\":{\"h\":\"特性\"},\"18\":{\"h\":\"原子性\",\"t\":[\"一个操作是不可中断的，要么全部执行成功要么全部执行失败。\"]},\"19\":{\"h\":\"可见性\",\"t\":[\"线程解锁前，必须把共享变量的最新值刷新到主内存中\",\"线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时从主内存中重新读取最新的值。\",\"volatile的可见性都是通过内存屏障来实现的。\",\"synchronized靠操作系统内存互斥锁实现，相当于JMM中的lock、unlock。退出代码块时刷新变量到主内存。\"]},\"20\":{\"h\":\"有序性\",\"t\":[\"as-if-serial：保证不管编译器和处理器为了性能优化会如何进行指令重排序，都需要保证单线程下的运行结果的正确性。即如果在本线程内观察，所有操作都是有序的；如果在一个线程观察另一个线程，所有操作都是无序的。\"]},\"21\":{\"h\":\"可重入性\",\"t\":[\"允许一个线程二次请求自己持有对象锁的临界资源。之所以是可以重入。是因为synchronized 锁对象有个计数器，会随着线程获取锁+1计数，当线程执行完毕后-1，直到清零释放锁。\"]},\"22\":{\"h\":\"ReentrantLock\",\"t\":[\"ReentrantLock 是基于 Lock 实现的可重入锁，所有的 Lock 都是基于 AQS 实 现的，AQS 和 Condition 各自维护不同的对象，在使用 Lock 和 Condition 时，其实就是两个队列的互相移动。它所提供的共享锁、互斥锁都是基于对 state 的操作。而它的可重入是因为实现了同步器 Sync，在 Sync 的两个实现类中， 包括了公平锁和非公平锁。\"]},\"23\":{\"h\":\"公平锁\",\"t\":[\"通过ReentrantLock的构造函数确认在创建时是否初始化公平锁判断公平锁，主要时根据方法tryAcquire中，是否存在!hasQueuedPredecessors()hasQueuedPredecessors()：判断当前线程是否是同步队列的首位\"]},\"24\":{\"h\":\"公平锁实现\"},\"25\":{\"h\":\"CLH\",\"t\":[\"CLH 是一种基于单向链表的高性能、公平的自旋锁。AQS 中的队列是 CLH 变体的虚拟双向队（FIFO），AQS 是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。CLH 队列锁的优点是空间复杂度低，在 SMP（Symmetric Multi-Processor）对称 多处理器结构（一台计算机由多个 CPU 组成，并共享内存和其他资源，所有的 CPU 都可以平等地访问内存、I/O 和外部中断）效果还是不错的。但在 NUMA(Non-Uniform Memory Access) 下效果就不太好了。\"]},\"26\":{\"h\":\"MCS\",\"t\":[\"MCS也是一种基于链表的可扩展、高性能、公平的自旋锁，但与 CLH 不同。它是真的有下一个节点 next，添加这个真实节点后，它就可以只在本地变量上自旋， 而 CLH 是前驱节点的属性上自旋。\"]},\"27\":{\"h\":\"TicketLock\",\"t\":[\"TicketLock 就像你去银行、呷哺给你的一个排号卡一样，叫到你号你才能进去。 属于严格的公平性实现，但是多处理器系统上，每个进程/线程占用的处理器都 在读写同一个变量，每次读写操作都需要进行多处理间的缓存同步，非常消耗系 统性能。 代码实现上也比较简单，lock() 中设置拥有者的号牌，并进入自旋比对。unlock() 中使用 CAS 进行解锁操作，并处理移除。\"]},\"28\":{\"h\":\"总结\",\"t\":[\"ReentrantLock 是基于 Lock 实现的可重入锁。\",\"ReentrantLock 使用起来更加灵活，可操作性也更大，但一定要在 finally 中释放锁，目的是保证在获取锁之后，最终能够被释放。同时不要将获取锁的过程写在 try 里面。\",\"公平锁的实现依据不同场景和 SMP、NUMA 的使用，会有不同的优劣效果。在实际的使用中一般默认会选择非公平锁，即使是自旋也是耗费性能的，一般会用在较 少等待的线程中，避免自旋时过长。\"]},\"29\":{\"h\":\"AQS\"},\"30\":{\"h\":\"垃圾回收机制\",\"t\":[\"内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。\"]},\"31\":{\"h\":\"方法区的回收\",\"t\":[\"方法区中能回收的内容主要就是不再使用的类。\",\"判定一个类可以被卸载。需要同时满足下面三个条件：\",\"此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。\",\"加载该类的类加载器已经被回收。\",\"该类对应的java.lang.Class对象没有在任何地方被引用。\"]},\"32\":{\"h\":\"堆回收\",\"t\":[\"Java中的对象是否能被回收，是根据对象是否被引用来决定的，即能否通过栈内存中的引用访问到实例对象。\",\"常见判断方法：引用计数器、可达性分析法\"]},\"33\":{\"h\":\"引用计数器\",\"t\":[\"引用计数器会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1 。\",\"优点：实现简单\",\"缺点：\",\"每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响。\",\"存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。\"]},\"34\":{\"h\":\"可达性分析算法\",\"t\":[\"可达性分析将对象分为两类：垃圾回收的根对象（GCRoot）和普通对象，对象与对象之间存在引用关系。\",\"可达性分析算法指如果某个到GC Root对象是科大的，对象就不可被回收。\",\"GCRoot对象：\",\"线程Thread对象，引用线程栈帧中的方法参数、局部变量等。\",\"系统类加载器加载的java.lang.Class对象，引用类中的静态变量。\",\"监视器对象，用来保存同步锁synchronized关键字持有的对象。\",\"本地方法调用时使用的全局对象。\"]},\"35\":{\"h\":\"对象引用\",\"t\":[\"可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，这要这层关系存在，普通对象就不会被回收。\",\"**对象引用方式：**强引用、软引用、弱引用、虚引用、终结器引用\"]},\"36\":{\"h\":\"软引用\",\"t\":[\"如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。\",\"在JDK 1.2之后提供了SoftReference类来实现软引用，软引用常用于缓存中。\",\"软引用执行流程\",\"将对象使用软引用包装起来，new SoftReference<对象类型>(对象)。\",\"内存不足时，虚拟机尝试进行垃圾回收。\",\"如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。\",\"如果内存依然不足，抛出OutOfMemory异常。\",\"SoftReference提供了一套队列机制：\",\"软引用创建时，通过构造器传入引用队列\",\"在软引用中包含的对象被回收时，该软引用对象会被放入引用队列\",\"通过代码遍历引用队列，将SoftReference的强引用删除\"]},\"37\":{\"h\":\"弱引用\",\"t\":[\"弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。\",\"在JDK 1.2之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLoacl中使用。\",\"弱引用对象本身也可以使用引用队列进行回收。\"]},\"38\":{\"h\":\"虚引用和终结器引用\",\"t\":[\"在常规开发中不会使用。\",\"虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是在当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。\",\"终结器引用指的是在对象需要被回收时，对象将会被放置在Finalizer类中的引用队列中，并在稍后由一条由FinalizeThread线程从队列中获取对象，然后执行对象的finalize方法。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。\"]},\"39\":{\"h\":\"垃圾回收算法\",\"t\":[\"垃圾回收要做两件事：\",\"找到内存中存活的对象\",\"释放不再存活对象的内存，使得程序能再次利用这部分空间\",\"Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为Stop The World简称STW，人如果STW时间过长则会影响用户的使用。\"]},\"40\":{\"h\":\"评价标准\",\"t\":[\"吞吐量\",\"吞吐量指的是CPU用来执行用户代码的时间与CPU总执行时间的比值，即吞吐量=执行用户代码时间/（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。\",\"最大暂停时间\",\"最大暂停时间指的是所有再垃圾回收过程中的STW时间最大值。最大暂停时间越短，用户使用系统时受到的影响就越短。\",\"堆使用效率\",\"不同的垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清楚算法要优于复制算法。\"]},\"41\":{\"h\":\"标记清除算法\",\"t\":[\"核心思想分为两个阶段：\",\"标记阶段：将所有存活的对象进行标记。Java中使用可达性分析算法，从GCRoot开始通过引用链遍历出所有存活对象。\",\"清除阶段：从内存中删除没有被标记也就是非存活对象。\",\"优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。\",\"缺点：\",\"碎片化问题\",\"由于内存是连续的，所以在对象被删除之后，内存中会出现很多的细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。\",\"分配速度慢\",\"由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。\"]},\"42\":{\"h\":\"复制算法\",\"t\":[\"核心思想：\",\"准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。\",\"在垃圾回收GC阶段，将From中存活对象复制到To空间。\",\"将两块空间的From和To名字互换。\",\"回收To空间中的对象\",\"优缺点：吞吐量高、不会发生碎片化、内存使用效率低\"]},\"43\":{\"h\":\"标记整理算法\",\"t\":[\"核心思想：\",\"标记阶段：将所有存活的对象进行标记。Java中使用可达性分析算法，从GCRoot开始通过引用链遍历出所有存活对象。\",\"整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。\",\"优缺点：内存使用效率高、不会发生碎片化、整理阶段的效率不高\"]},\"44\":{\"h\":\"分代垃圾回收算法⭐\",\"t\":[\"分代垃圾回收会将整个区域划分为年轻代（存放存活时间比较短的对象）和老年代（存放存活时间比较长的对象）。\",\"年轻代包含Eden、S0（Form）、S1（To）区。\",\"分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。\",\"随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为MinorGC或者YoungGC。\",\"MinorGC会把需要Eden中和From选哟回收的对象回收，把没有回收的对象放入To区。\",\"每次MinorGC都会为对象记录他的年龄，初始值为0，每次GC完加1。\",\"如果MinorGC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。\",\"当老年代中空间不足，无法放入新的对象时，先尝试MinorGC如果还是不足，就会触发FullGC，FullGC会对整个堆进行垃圾回收。\",\"为什么分代GC算法要把堆分成年轻代和老年代？\",\"系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。\",\"老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。\",\"在虚拟机的默认设置中，新生代大小要远小于老年代的大小。\",\"主要原因\",\"可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。\",\"新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记清除和标记整理算法，由程序员来选择灵活度较高。\",\"分代的设计中允许只回收新生代（MinorGC），如果能满足对象分配的要求就不需要对整个堆进行回收（FullGC），STW时间就会减少。\"]},\"45\":{\"h\":\"垃圾回收器\"},\"46\":{\"h\":\"年轻代——Serial垃圾回收器\",\"t\":[\"Serial是一种单线程串行回收年轻代的垃圾回收器。\",\"回收年代： 年轻代\",\"回收算法： 复制算法\",\"优点： 单CPU处理器下吞吐量非常出色\",\"缺点： 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待\",\"适用场景：Java编写的客户端程序或者硬件配置有限的场景\"]},\"47\":{\"h\":\"老年代——SerialOld垃圾回收器\",\"t\":[\"SerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收。\",\"回收年代： 老年代\",\"回收算法： 标记整理算法\",\"优点： 单CPU处理器下吞吐量非常出色\",\"缺点： 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待\",\"适用场景： 与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用\"]},\"48\":{\"h\":\"年轻代——ParNew垃圾回收器\",\"t\":[\"ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收。\",\"回收年代： 年轻代\",\"回收算法： 复制算法\",\"优点： 多CPU处理器下停顿时间较短\",\"缺点： 吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用\",\"使用场景：JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用\"]},\"49\":{\"h\":\"老年代——CMS（Concurrent Mark Sweep）垃圾回收器\",\"t\":[\"CMS垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行每减少了用户线程的等待时间。\",\"回收年代： 老年代\",\"回收算法： 标记清除算法\",\"优点： 系统由于垃圾回收出现的停顿时间较短，用户体验好\",\"缺点： 内存碎片化问题、退化问题、浮动垃圾问题\",\"使用场景： 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等\",\"CMS执行步骤\",\"初始标记，用极短的时间标记出GCRoot能直接关联到的对象。\",\"并发标记，标记所有的对象，用户线程不需要暂停。\",\"重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。\",\"并发清理，清理死亡的对象，用户线程不需要暂停。\"]},\"50\":{\"h\":\"年轻代——Parallel Scavenge垃圾回收器\",\"t\":[\"Parallel Scavenge是JDK8默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。具备自动调整堆内存大小的特点。\",\"回收年代： 年轻代\",\"回收算法： 复制算法\",\"优点： 吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数\",\"缺点： 不能保证单次的停顿时间\",\"适用场景： 后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出\"]},\"51\":{\"h\":\"老年代——Parallel Old垃圾回收器\",\"t\":[\"Parallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。\",\"回收年代： 老年代\",\"回收算法： 标记整理算法\",\"优点： 并发收集，在多核CPU下效率较高\",\"缺点： 暂停时间会比较长\",\"适用场景： 与Parallel Scavenge配套使用\"]},\"52\":{\"h\":\"G1垃圾回收器\",\"t\":[\"回收年代： 年轻代+老年代\",\"回收算法： 复制算法\",\"优点： 对比较大的堆如超过6G的堆回收时，延迟可控，不会产生内存碎片，并发标记的SATB算法效率高\",\"缺点：JDK8之前还不够成熟\",\"适用场景：JDK8最新版本、JDK9之后建议默认使用\",\"JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器，将Parallel Scavenge与CMS的优点融合。\",\"支持巨大的堆空间回收，并有较高的吞吐量；支持多CPU并行垃圾回收；允许用户设置最大暂停时间。\",\"G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的，分为Eden、Survivor、Old区。Region的大小通过堆空间大小/2048计算得到，Region size必须是2的指数幂，取值范围从1M到32M。\",\"垃圾回收方式：年轻代回收（Young GC）、混合回收（Mixed GC）\",\"年轻代回收：回收Eden区和Survivor区中不用的对象，会导致STW。\",\"执行流程\",\"新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行Young GC。\",\"标记出Eden和Survivor区域中的存活对象。\",\"根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。\",\"后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。\",\"当某个存活对象的年龄达到阈值（默认15），会被放入老年代。\",\"部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。\",\"多次回收过后，会出现很多Old老年代区，此时总堆占有率达到阈值时会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。\",\"G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。\",\"混合回收分为：初始标记、并发标记、最终标记、并发清理\",\"G1对老年代的清理会选择存活度最低的区域来进行回收，这个可以保证回收效率最高，这也是G1名称的由来。\",\"Caution\",\"如果清理过程中发现没有足够的空Region存放转移的对象，会出现FullGC。单线程执行标记整理算法，此时会导致用户线程的暂停。所以尽量保证该应用的堆内存有一定多余的空间。\"]},\"53\":{\"h\":\"字节码文件\",\"t\":[\"字节码文件中保存了源代码编译之后的内容，以二进制的方式存储，无法直接用记事本打开阅读。\",\"使用 jclasslib 工具\",\"javap -v 字节码文件名称：查看字节码文件内容\",\"Arthas 线上监控诊断工具\"]},\"54\":{\"h\":\"文件组成\",\"t\":[\"基本信息、常量池、字段、方法、属性\"]},\"55\":{\"h\":\"基本信息\",\"t\":[\"包含魔数、字节码文件对应的 Java 版本号访问标识（public final 等等）父类和接口\",\"Magic 魔数\",\"文件是无法通过文件拓展名来确认文件类型的，文件拓展名可以随意修改，不影响文件的内容 。\",\"软件使用文件的**头几个字节（文件头）**去校验文件的类型，如果软件不支持该种类型就会出错。\",\"Java 字节码文件中，将文件头称为魔数。\",\"主副版本号\",\"主副版本号指的是编译字节码文件的 JDK 版本号，主版本号用来标识大版本号，JDK 1.0-1.1使用了45.0-45.3，JDK 1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需关注主版本号。\",\"版本号的作用主要是判断当前字节码的版本和运行时的 JDK 是否兼容。\"]},\"56\":{\"h\":\"常量池\",\"t\":[\"保存了字符串常量、类或接口名、字段名主要在字节码指令中使用\",\"作用：避免相同的内容重复定义，节省空间。\",\"常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。\",\"字节码指令中通过编号引用到常量池的过程称之为符号引用。\"]},\"57\":{\"h\":\"字段\",\"t\":[\"当前类或接口声明的字段信息\"]},\"58\":{\"h\":\"方法\",\"t\":[\"当前类或接口声明的方法信息字节码指令\",\"字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。\",\"操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置属性\",\"类的属性，比如源码的文件名、内部类的列表等\"]},\"59\":{\"h\":\"类加载器\"},\"60\":{\"h\":\"类的生命周期\",\"t\":[\"概述\",\"类的生命周期描述了一个类加载、使用、卸载的整个过程\",\"加载 →连接→初始化→使用→卸载\",\"连接：验证→准备→解析\"]},\"61\":{\"h\":\"加载阶段（Loading）\",\"t\":[\"类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。\",\"类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中。\",\"类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。 在方法区中生成一个InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。\",\"同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。\",\"作用是在Java代码中去获取类的信息以及存储静态字段的数据（ JDK 8及以后）。\",\"对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。\",\"这样Java虚拟机就能很好地控制开发者访问数据的范围。\"]},\"62\":{\"h\":\"连接阶段（Linking）\",\"t\":[\"包含\",\"验证：验证内容是否满足《Java虚拟机规范》\",\"准备：给静态变量赋初值\",\"解析：将常量池中的符号引用替换成指向内存的直接引用\"]},\"63\":{\"h\":\"连接阶段——验证\",\"t\":[\"目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与\",\"主要包含如下四个部分：\",\"文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求\",\"元信息验证，例如类必须有父类（super不能为空）\",\"验证程序指向指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去\",\"符号引用验证，例如是否访问了其他类中private的方法等\"]},\"64\":{\"h\":\"连接阶段——准备\",\"t\":[\"为静态变量（static）分配内存并设置初始值\",\"final修饰的基本数据类型的静态变量，直接会将代码中的值进行赋值\"]},\"65\":{\"h\":\"连接阶段——解析\",\"t\":[\"主要是将常量池中的符号引用[1]替换为直接引用[2]。\"]},\"66\":{\"h\":\"\",\"t\":[\"初始化阶段会执行静态代码块中的代码，并为静态变量赋值。\",\"初始化阶段会执行字节码文件中clinit部分的字节码指令。\",\"以下几种方式会导致类的初始化：\",\"访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是不会触发初始化。\",\"调用Class.forName(String className)。\",\"new一个该类的对象时。\",\"执行Main方法的当前类。\",\"clinit指令在特定情况下不会出现：\",\"无静态代码块且无静态变量赋值语句。\",\"有静态变量的声明，但是没有赋值语句。\",\"静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。\",\"直接访问父类的静态变量，不会触发子类的初始化。\",\"子类的初始化clinit调用之前，会先调用父类的clinit初始化方法。\",\"数组的创建不会导致数组中元素的类进行初始化。\"]},\"67\":{\"h\":\"类加载器（ClassLoader）\",\"t\":[\"类加载器是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。\",\"类加载器只参与加载过程中的字节码获取并加载到内存这一部分。\",\"作用：负责类加载过程中字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换成byte[]，接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。\"]},\"68\":{\"h\":\"类加载器的分类\",\"t\":[\"类加载器分为两类，一类是Java代码实现的，一类是Java虚拟机底层源码实现的。\"]},\"69\":{\"h\":\"虚拟机底层实现\",\"t\":[\"启动类加载器（Bootstrap）——加载Java中最核心的类（C++，JDK8）\",\"启动类加载器（BootClassLoader）（Java，JDK9）——继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件，==启动类加载器依然无法通过Java代码获取到，返回的仍然是null，保持了统一。\"]},\"70\":{\"h\":\"Java代码实现\",\"t\":[\"扩展类加载器（Extension）——允许拓展Java中比较通用的类，继承自URLClassLoader（JDK8）\",\"平台类加载器（PlatformClassLoader）——继承自BuiltinClassLoader。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。（JDK9）\",\"应用类加载器（Application）——加载应用使用的类（JDK8与JDK9，继承关系发生变化）\"]},\"71\":{\"h\":\"双亲委派机制⭐\",\"t\":[\"双亲委派机制的核心是解决一个类到底由谁加载的问题。\",\"作用：\",\"保证类加载的安全性——避免恶意代码替换JDK中的核心库\",\"避免重复加载——避免同一个类被多次加载\",\"概念： 当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载。\",\"每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。\",\"如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。\",\"第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回。\",\"向下委派加载起到了一个加载优先级的作用。\"]},\"72\":{\"h\":\"打破双亲委派机制⭐\",\"t\":[\"方式：\",\"自定义类加载器——自定义类加载器并且重写loadClass方法，就可以将双亲委派机制的代码去除；Tomcat通过这种方式实现应用之间类隔离\",\"线程上下文类加载器——利用上下文类加载器加载类，比如JDBC和JNDI等，使用SPI机制+线程上下文加载器，通过Thread.currentThread().getContextClassLoader()获取应用类加载器——没有打破\",\"Osgi框架的类加载器——历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载\"]},\"73\":{\"h\":\"自定义类加载器\",\"t\":[\"//类加载的入口，提供了双亲委托机制。内部会调用findClass public Class<?> loadClass(String name) //由类加载器子类实现，获取二进制数据调用defineClass，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据 protected Class<?> findClass(String name) //做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中 protected final Class<?> defineClass(String name,byte[] b,int off,int len) //执行类生命周期中的连接阶段 protected final void resolveClass(Class<?> c)\",\"正确的去实现一个自定义类加载器的方式是重写findClass方法，这样不会破坏双亲委派机制。\",\"源码解析\",\"符号引用就是在字节码文件中使用编号来访问常量池中的内容 ↩︎\",\"直接引用就是不在使用编号来访问内容，而是使用内存中的地址进行访问具体的数据 ↩︎\"]},\"74\":{\"h\":\"运行时数据区\",\"t\":[\"Java虚拟机在运行Java程序过程中管理的内存区域，被称之为运行时数据区。\"]},\"75\":{\"h\":\"程序计数器（Program Counter Register）\",\"t\":[\"程序计数器也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址。\",\"程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。\",\"在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。\"]},\"76\":{\"h\":\"Java虚拟机栈（Java Virtual Machine Stack）\",\"t\":[\"Java虚拟机栈采用栈的数据结构来管理方法调用中的基本数据，先进后出（First in Out），每一个方法的调用使用一个栈帧（Stack Frame）来保存。\",\"Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。\",\"栈帧的组成：局部变量表、操作数栈、帧数据\"]},\"77\":{\"h\":\"局部变量表\",\"t\":[\"局部变量表的作用是在运行过程中存放所有的局部变量。\",\"栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽（slot），long和double类型占用两个槽，其他类型占用一个槽。\",\"方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。\",\"局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。\",\"为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。\"]},\"78\":{\"h\":\"操作数栈\",\"t\":[\"操作数栈是栈帧中虚拟机在执行指令过程中用来存放中件数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。\",\"在编译期就可以确认操作数栈的最大深度，从而在执行时正确的分配内存大小。\"]},\"79\":{\"h\":\"帧数据\",\"t\":[\"当前类的字节码指令引用了其他类的属性或方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就要保存了编号到运行时常量池的内存地址的映射关系。\",\"方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。\",\"异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。\"]},\"80\":{\"h\":\"本地方法栈\",\"t\":[\"Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。\",\"在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。\"]},\"81\":{\"h\":\"堆\",\"t\":[\"一般Java程序中堆内存时空间最大的一块内存区域。创建出来的对象都存在与堆上。\",\"栈上的局部变量表中中，可以存放对上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。\",\"堆空间有三个需要关注的值：used、total、max。\",\"used指的是当前已使用的堆内存，total是Java虚拟机已经分配的可用堆内存，max是Java虚拟机可以分配的最大堆内存。\",\"随着堆中的对象增多，当total可以使用的内存即将不足时，Java虚拟机会继续分配内存给堆。\"]},\"82\":{\"h\":\"方法区（Method Area）\",\"t\":[\"方法区时存放基础信息的位置，线程共享，主要包含：类的元信息、运行时常量池、字符串常量池。\",\"类的元信息\",\"方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。\",\"运行时常量池\",\"常量池中存放的是字节码中的常量池内容。\",\"字节码文件中通过编号查表得方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速得定位到常量池中的内容，这种常量池称为运行时常量池。\",\"字符串常量池\",\"字符串常量池存储在代码中定义的常量字符串内容。比如 ”123“ 这个123就会被放入字符串常量池。\",\"JDK7之后版本由于字符串常量池在堆上，所有intern()方法会把第一次遇到的字符串的引用放入字符串常量池。\",\"JDK7之后版本，静态变量是存放在堆中的Class对象中，脱离了永久代。\"]},\"83\":{\"h\":\"直接内存（Direct Memory）\",\"t\":[\"直接内存并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。\",\"在JDK 1.4 中引入了NIO机制，使用了直接内存，主要解决以下两个问题：\",\"Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。\",\"IO操作比如读文件，需要先把文件读入直接内存（缓存区）再把数据复制到Java堆中。\",\"现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。\"]},\"84\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"85\":{\"h\":\"Resolve\"},\"86\":{\"h\":\"Java\"},\"87\":{\"h\":\"Technology\"},\"88\":{\"h\":\"Jvm\"}},\"dirtCount\":0,\"index\":[[\"写文件也是类似的思路\",{\"1\":{\"83\":1}}],[\"减少了数据复制的开销\",{\"1\":{\"83\":1}}],[\"减少碰撞\",{\"1\":{\"11\":1}}],[\"现在直接放入直接内存即可\",{\"1\":{\"83\":1}}],[\"现的\",{\"1\":{\"22\":1}}],[\"缓存区\",{\"1\":{\"83\":1}}],[\"direct\",{\"0\":{\"83\":1}}],[\"defineclass\",{\"1\":{\"73\":1}}],[\"脱离了永久代\",{\"1\":{\"82\":1}}],[\"元信息\",{\"1\":{\"82\":1}}],[\"元信息验证\",{\"1\":{\"63\":1}}],[\"随着堆中的对象增多\",{\"1\":{\"81\":1}}],[\"随着对象在eden区越来越多\",{\"1\":{\"44\":1}}],[\"used指的是当前已使用的堆内存\",{\"1\":{\"81\":1}}],[\"used\",{\"1\":{\"81\":1}}],[\"uniform\",{\"1\":{\"25\":1}}],[\"unlock\",{\"1\":{\"19\":1,\"27\":1}}],[\"静态变量是存放在堆中的class对象中\",{\"1\":{\"82\":1}}],[\"静态变量也可以存放堆对象的引用\",{\"1\":{\"81\":1}}],[\"静态变量的定义使用final关键字\",{\"1\":{\"66\":1}}],[\"栈上的局部变量表中中\",{\"1\":{\"81\":1}}],[\"栈帧中的局部变量表是一个数组\",{\"1\":{\"77\":1}}],[\"栈帧的组成\",{\"1\":{\"76\":1}}],[\"临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来\",{\"1\":{\"80\":1}}],[\"本地方法栈会在栈内存上生成一个栈帧\",{\"1\":{\"80\":1}}],[\"本地方法栈\",{\"0\":{\"80\":1}}],[\"本地方法调用时使用的全局对象\",{\"1\":{\"34\":1}}],[\"异常表存放的是代码中异常的处理信息\",{\"1\":{\"79\":1}}],[\"异常等逻辑\",{\"1\":{\"75\":1}}],[\"动态链接就要保存了编号到运行时常量池的内存地址的映射关系\",{\"1\":{\"79\":1}}],[\"转换成对应的运行时常量池中的内存地址\",{\"1\":{\"79\":1}}],[\"转换成方法区和堆中的数据\",{\"1\":{\"67\":1}}],[\"编号\",{\"1\":{\"79\":1}}],[\"编号从1开始\",{\"1\":{\"56\":1}}],[\"他是一种栈式的数据结构\",{\"1\":{\"78\":1}}],[\"他的整体结构是一个node数组\",{\"1\":{\"3\":1}}],[\"其顺序与方法中参数定义的顺序一致\",{\"1\":{\"77\":1}}],[\"其他类型占用一个槽\",{\"1\":{\"77\":1}}],[\"其实就是两个队列的互相移动\",{\"1\":{\"22\":1}}],[\"帧数据\",{\"0\":{\"79\":1},\"1\":{\"76\":1}}],[\"操作数栈是栈帧中虚拟机在执行指令过程中用来存放中件数据的一块区域\",{\"1\":{\"78\":1}}],[\"操作数栈是临时存放数据的地方\",{\"1\":{\"58\":1}}],[\"操作数栈\",{\"0\":{\"78\":1},\"1\":{\"76\":1}}],[\"来保存\",{\"1\":{\"76\":1}}],[\"来确保变量对所有线程的可见性\",{\"1\":{\"15\":1}}],[\"跳转\",{\"1\":{\"75\":1}}],[\"程序计数器可以控制程序指令的进行\",{\"1\":{\"75\":1}}],[\"程序计数器也叫pc寄存器\",{\"1\":{\"75\":1}}],[\"程序计数器\",{\"0\":{\"75\":1}}],[\"被称之为运行时数据区\",{\"1\":{\"74\":1}}],[\"运行时常量池\",{\"1\":{\"82\":2}}],[\"运行时数据区\",{\"0\":{\"74\":1}}],[\"运算\",{\"1\":{\"8\":1}}],[\"↩︎\",{\"1\":{\"73\":2}}],[\"符号引用就是在字节码文件中使用编号来访问常量池中的内容\",{\"1\":{\"73\":1}}],[\"符号引用验证\",{\"1\":{\"63\":1}}],[\"源码解析\",{\"1\":{\"73\":1}}],[\"正确的去实现一个自定义类加载器的方式是重写findclass方法\",{\"1\":{\"73\":1}}],[\"然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中\",{\"1\":{\"73\":1}}],[\"然后执行对象的finalize方法\",{\"1\":{\"38\":1}}],[\"做一些类名的校验\",{\"1\":{\"73\":1}}],[\"获取二进制数据调用defineclass\",{\"1\":{\"73\":1}}],[\"获取应用类加载器\",{\"1\":{\"72\":1}}],[\"提供了双亲委托机制\",{\"1\":{\"73\":1}}],[\"提高内存的利用率和性能\",{\"1\":{\"44\":1}}],[\"历史上osgi框架实现了一套新的类加载器机制\",{\"1\":{\"72\":1}}],[\"没有打破\",{\"1\":{\"72\":1}}],[\"利用上下文类加载器加载类\",{\"1\":{\"72\":1}}],[\"利用多线程并发收集\",{\"1\":{\"51\":1}}],[\"打破双亲委派机制⭐\",{\"0\":{\"72\":1}}],[\"向下委派加载起到了一个加载优先级的作用\",{\"1\":{\"71\":1}}],[\"仍然会向上进行委派\",{\"1\":{\"71\":1}}],[\"第二次再去加载相同的类\",{\"1\":{\"71\":1}}],[\"第二阶段删除对象即可\",{\"1\":{\"41\":1}}],[\"否则会将加载请求委派给父类加载器\",{\"1\":{\"71\":1}}],[\"否则只是扩容\",{\"1\":{\"12\":1}}],[\"再把数据复制到java堆中\",{\"1\":{\"83\":1}}],[\"再由顶向下进行加载\",{\"1\":{\"71\":1}}],[\"再返回即可\",{\"1\":{\"10\":1}}],[\"概念\",{\"1\":{\"71\":1}}],[\"概述\",{\"1\":{\"60\":1}}],[\"双亲委派机制的核心是解决一个类到底由谁加载的问题\",{\"1\":{\"71\":1}}],[\"双亲委派机制⭐\",{\"0\":{\"71\":1}}],[\"继承关系发生变化\",{\"1\":{\"70\":1}}],[\"继承自builtinclassloader\",{\"1\":{\"70\":1}}],[\"继承自builtinclassloader实现从模块中找到要加载的字节码资源文件\",{\"1\":{\"69\":1}}],[\"继承自urlclassloader\",{\"1\":{\"70\":1}}],[\"应用类加载器\",{\"1\":{\"70\":1}}],[\"自定义类加载器并且重写loadclass方法\",{\"1\":{\"72\":1}}],[\"自定义类加载器\",{\"0\":{\"73\":1},\"1\":{\"72\":1}}],[\"自身没有特殊的逻辑\",{\"1\":{\"70\":1}}],[\"自我介绍\",{\"1\":{\"1\":1}}],[\"平台类加载器的存在更多的是为了与老版本的设计方案兼容\",{\"1\":{\"70\":1}}],[\"平台类加载器\",{\"1\":{\"70\":1}}],[\"extension\",{\"1\":{\"70\":1}}],[\"扩展类加载器\",{\"1\":{\"70\":1}}],[\"扩容实现流程\",{\"0\":{\"7\":1}}],[\"b\",{\"1\":{\"73\":1}}],[\"byte\",{\"1\":{\"73\":1}}],[\"bootclassloader\",{\"1\":{\"69\":1}}],[\"bootstrap\",{\"1\":{\"69\":1}}],[\"b同时引用a时会出现对象无法回收的问题\",{\"1\":{\"33\":1}}],[\"启动类加载器\",{\"1\":{\"69\":2}}],[\"接下来调用虚拟机底层方法将byte\",{\"1\":{\"67\":1}}],[\"负责类加载过程中字节码获取并加载到内存这一部分\",{\"1\":{\"67\":1}}],[\"负载因子\",{\"0\":{\"11\":1}}],[\"子类的初始化clinit调用之前\",{\"1\":{\"66\":1}}],[\"有静态变量的声明\",{\"1\":{\"66\":1}}],[\"有序性\",{\"0\":{\"20\":1}}],[\"无静态代码块且无静态变量赋值语句\",{\"1\":{\"66\":1}}],[\"无法直接用记事本打开阅读\",{\"1\":{\"53\":1}}],[\"无法分配对象时需要回收时会执行young\",{\"1\":{\"52\":1}}],[\"无法放入新的对象时\",{\"1\":{\"44\":1}}],[\"调用class\",{\"1\":{\"66\":1}}],[\"调用afternoderemoval\",{\"1\":{\"6\":1}}],[\"注意变量是final修饰的并且等号右边是不会触发初始化\",{\"1\":{\"66\":1}}],[\"访问一个类的静态变量或者静态方法\",{\"1\":{\"66\":1}}],[\"替换为直接引用\",{\"1\":{\"65\":1}}],[\"例如是否访问了其他类中private的方法等\",{\"1\":{\"63\":1}}],[\"例如类必须有父类\",{\"1\":{\"63\":1}}],[\"目的是检测java字节码文件是否遵守了\",{\"1\":{\"63\":1}}],[\"目的是保证在获取锁之后\",{\"1\":{\"28\":1}}],[\"解析\",{\"0\":{\"65\":1},\"1\":{\"62\":1}}],[\"给静态变量赋初值\",{\"1\":{\"62\":1}}],[\"准备\",{\"0\":{\"64\":1},\"1\":{\"62\":1}}],[\"准备两块空间from空间和to空间\",{\"1\":{\"42\":1}}],[\"验证程序指向指令的语义\",{\"1\":{\"63\":1}}],[\"验证内容是否满足\",{\"1\":{\"62\":1}}],[\"验证\",{\"0\":{\"63\":1},\"1\":{\"62\":1}}],[\"验证→准备→解析\",{\"1\":{\"60\":1}}],[\"连接阶段\",{\"0\":{\"62\":1,\"63\":1,\"64\":1,\"65\":1}}],[\"连接\",{\"1\":{\"60\":1}}],[\"→连接→初始化→使用→卸载\",{\"1\":{\"60\":1}}],[\"加载应用使用的类\",{\"1\":{\"70\":1}}],[\"加载java中最核心的类\",{\"1\":{\"69\":1}}],[\"加载阶段\",{\"0\":{\"61\":1}}],[\"加载\",{\"1\":{\"60\":1}}],[\"加载该类的类加载器已经被回收\",{\"1\":{\"31\":1}}],[\"卸载的整个过程\",{\"1\":{\"60\":1}}],[\"内部会调用findclass\",{\"1\":{\"73\":1}}],[\"内部类的列表等\",{\"1\":{\"58\":1}}],[\"内存碎片化问题\",{\"1\":{\"49\":1}}],[\"内存使用效率高\",{\"1\":{\"43\":1}}],[\"内存使用效率低\",{\"1\":{\"42\":1}}],[\"内存中会出现很多的细小的可用内存单元\",{\"1\":{\"41\":1}}],[\"内存不足时\",{\"1\":{\"36\":1}}],[\"内存泄漏的积累可能会导致内存溢出\",{\"1\":{\"30\":1}}],[\"内存泄漏指的是不再使用的对象在系统中未被回收\",{\"1\":{\"30\":1}}],[\"类加载的入口\",{\"1\":{\"73\":1}}],[\"类加载器分为两类\",{\"1\":{\"68\":1}}],[\"类加载器的分类\",{\"0\":{\"68\":1}}],[\"类加载器只参与加载过程中的字节码获取并加载到内存这一部分\",{\"1\":{\"67\":1}}],[\"类加载器是java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术\",{\"1\":{\"67\":1}}],[\"类加载器在加载完类之后\",{\"1\":{\"61\":2}}],[\"类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息\",{\"1\":{\"61\":1}}],[\"类加载器\",{\"0\":{\"59\":1,\"67\":1}}],[\"类的元信息\",{\"1\":{\"82\":2}}],[\"类的生命周期描述了一个类加载\",{\"1\":{\"60\":1}}],[\"类的生命周期\",{\"0\":{\"60\":1}}],[\"类的属性\",{\"1\":{\"58\":1}}],[\"类或接口名\",{\"1\":{\"56\":1}}],[\"局部变量表中的槽是可以复用的\",{\"1\":{\"77\":1}}],[\"局部变量表保存的内容有\",{\"1\":{\"77\":1}}],[\"局部变量表的作用是在运行过程中存放所有的局部变量\",{\"1\":{\"77\":1}}],[\"局部变量表\",{\"0\":{\"77\":1},\"1\":{\"76\":1}}],[\"局部变量表是存放方法中的局部变量的位置属性\",{\"1\":{\"58\":1}}],[\"局部变量等\",{\"1\":{\"34\":1}}],[\"节省空间\",{\"1\":{\"56\":1}}],[\"避免同一个类被多次加载\",{\"1\":{\"71\":1}}],[\"避免重复加载\",{\"1\":{\"71\":1}}],[\"避免恶意代码替换jdk中的核心库\",{\"1\":{\"71\":1}}],[\"避免相同的内容重复定义\",{\"1\":{\"56\":1}}],[\"避免自旋时过长\",{\"1\":{\"28\":1}}],[\"作用是在java代码中去获取类的信息以及存储静态字段的数据\",{\"1\":{\"61\":1}}],[\"作用\",{\"1\":{\"56\":1,\"67\":1,\"71\":1}}],[\"作为修饰符出现\",{\"1\":{\"15\":1}}],[\"保证类加载的安全性\",{\"1\":{\"71\":1}}],[\"保证不管编译器和处理器为了性能优化会如何进行指令重排序\",{\"1\":{\"20\":1}}],[\"保持了统一\",{\"1\":{\"69\":1}}],[\"保存类的所有信息\",{\"1\":{\"61\":1}}],[\"保存了字符串常量\",{\"1\":{\"56\":1}}],[\"副版本号是当主版本号相同时作为区分不同版本的标识\",{\"1\":{\"55\":1}}],[\"3\",{\"1\":{\"55\":1}}],[\"版本号的作用主要是判断当前字节码的版本和运行时的\",{\"1\":{\"55\":1}}],[\"版本号\",{\"1\":{\"55\":1}}],[\"版本号访问标识\",{\"1\":{\"55\":1}}],[\"主次版本号是否满足当前java虚拟机版本要求\",{\"1\":{\"63\":1}}],[\"主版本号用来标识大版本号\",{\"1\":{\"55\":1}}],[\"主副版本号指的是编译字节码文件的\",{\"1\":{\"55\":1}}],[\"主副版本号\",{\"1\":{\"55\":1}}],[\"主要解决以下两个问题\",{\"1\":{\"83\":1}}],[\"主要包含\",{\"1\":{\"82\":1}}],[\"主要包含如下四个部分\",{\"1\":{\"63\":1}}],[\"主要是将常量池中的符号引用\",{\"1\":{\"65\":1}}],[\"主要原因\",{\"1\":{\"44\":1}}],[\"主要时根据方法tryacquire中\",{\"1\":{\"23\":1}}],[\"去校验文件的类型\",{\"1\":{\"55\":1}}],[\"头几个字节\",{\"1\":{\"55\":1}}],[\"软件使用文件的\",{\"1\":{\"55\":1}}],[\"软引用创建时\",{\"1\":{\"36\":1}}],[\"软引用执行流程\",{\"1\":{\"36\":1}}],[\"软引用常用于缓存中\",{\"1\":{\"36\":1}}],[\"软引用\",{\"0\":{\"36\":1},\"1\":{\"35\":1}}],[\"文件格式验证\",{\"1\":{\"63\":1}}],[\"文件头\",{\"1\":{\"55\":1}}],[\"文件拓展名可以随意修改\",{\"1\":{\"55\":1}}],[\"文件是无法通过文件拓展名来确认文件类型的\",{\"1\":{\"55\":1}}],[\"文件组成\",{\"0\":{\"54\":1}}],[\"魔数\",{\"1\":{\"55\":1}}],[\"父类和接口\",{\"1\":{\"55\":1}}],[\"等等\",{\"1\":{\"55\":1}}],[\"包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置\",{\"1\":{\"79\":1}}],[\"包含\",{\"1\":{\"62\":1}}],[\"包含魔数\",{\"1\":{\"55\":1}}],[\"包括了公平锁和非公平锁\",{\"1\":{\"22\":1}}],[\"属性\",{\"1\":{\"54\":1}}],[\"属于严格的公平性实现\",{\"1\":{\"27\":1}}],[\"字符串常量池存储在代码中定义的常量字符串内容\",{\"1\":{\"82\":1}}],[\"字符串常量池\",{\"1\":{\"82\":2}}],[\"字节码指令的内容存放在方法的code属性中\",{\"1\":{\"58\":1}}],[\"字节码指令中通过编号引用到常量池的过程称之为符号引用\",{\"1\":{\"56\":1}}],[\"字节码中的方法区域是存放字节码指令的核心位置\",{\"1\":{\"58\":1}}],[\"字节码文件中通过编号查表得方式找到常量\",{\"1\":{\"82\":1}}],[\"字节码文件中\",{\"1\":{\"55\":1}}],[\"字节码文件中保存了源代码编译之后的内容\",{\"1\":{\"53\":1}}],[\"字节码文件对应的\",{\"1\":{\"55\":1}}],[\"字节码文件名称\",{\"1\":{\"53\":1}}],[\"字节码文件\",{\"0\":{\"53\":1}}],[\"字段名主要在字节码指令中使用\",{\"1\":{\"56\":1}}],[\"字段\",{\"0\":{\"57\":1},\"1\":{\"54\":1}}],[\"常量池中存放的是字节码中的常量池内容\",{\"1\":{\"82\":1}}],[\"常量池中的数据都有一个编号\",{\"1\":{\"56\":1}}],[\"常量池\",{\"0\":{\"56\":1},\"1\":{\"54\":1}}],[\"常见判断方法\",{\"1\":{\"32\":1}}],[\"基本信息\",{\"0\":{\"55\":1},\"1\":{\"54\":1}}],[\"线上监控诊断工具\",{\"1\":{\"53\":1}}],[\"线程共享\",{\"1\":{\"82\":1}}],[\"线程上下文类加载器\",{\"1\":{\"72\":1}}],[\"线程thread对象\",{\"1\":{\"34\":1}}],[\"线程占用的处理器都\",{\"1\":{\"27\":1}}],[\"线程加锁前\",{\"1\":{\"19\":1}}],[\"线程解锁前\",{\"1\":{\"19\":1}}],[\"查看字节码文件内容\",{\"1\":{\"53\":1}}],[\"工具\",{\"1\":{\"53\":1}}],[\"单线程执行标记整理算法\",{\"1\":{\"52\":1}}],[\"单cpu处理器下吞吐量非常出色\",{\"1\":{\"46\":1,\"47\":1}}],[\"采用复制算法来完成\",{\"1\":{\"52\":1}}],[\"采用单线程串行回收\",{\"1\":{\"47\":1}}],[\"此时会导致用户线程的暂停\",{\"1\":{\"52\":1}}],[\"此时总堆占有率达到阈值时会触发混合回收mixedgc\",{\"1\":{\"52\":1}}],[\"此类所有实例对象都已经被回收\",{\"1\":{\"31\":1}}],[\"部分对象如果大小超过region的一半\",{\"1\":{\"52\":1}}],[\"默认15\",{\"1\":{\"52\":1}}],[\"默认值和垃圾回收器有关\",{\"1\":{\"44\":1}}],[\"后续young\",{\"1\":{\"52\":1}}],[\"后台任务\",{\"1\":{\"50\":1}}],[\"年龄+1\",{\"1\":{\"52\":1}}],[\"年轻代回收\",{\"1\":{\"52\":2}}],[\"年轻代+老年代\",{\"1\":{\"52\":1}}],[\"年轻代\",{\"0\":{\"46\":1,\"48\":1,\"50\":1},\"1\":{\"46\":1,\"48\":1,\"50\":1}}],[\"年轻代包含eden\",{\"1\":{\"44\":1}}],[\"执行类生命周期中的连接阶段\",{\"1\":{\"73\":1}}],[\"执行main方法的当前类\",{\"1\":{\"66\":1}}],[\"执行流程\",{\"1\":{\"52\":1}}],[\"执行用户代码时间\",{\"1\":{\"40\":1}}],[\"混合回收分为\",{\"1\":{\"52\":1}}],[\"混合回收\",{\"1\":{\"52\":1}}],[\"young\",{\"1\":{\"52\":1}}],[\"取值范围从1m到32m\",{\"1\":{\"52\":1}}],[\"取消引用时减1\",{\"1\":{\"33\":1}}],[\"称之为区region\",{\"1\":{\"52\":1}}],[\"称为minorgc或者younggc\",{\"1\":{\"44\":1}}],[\"支持多cpu并行垃圾回收\",{\"1\":{\"52\":1}}],[\"支持巨大的堆空间回收\",{\"1\":{\"52\":1}}],[\"延迟可控\",{\"1\":{\"52\":1}}],[\"暂停时间会比较长\",{\"1\":{\"51\":1}}],[\"大文件导出\",{\"1\":{\"50\":1}}],[\"大数据的处理\",{\"1\":{\"50\":1}}],[\"大型的互联网系统中用户请求数据量大\",{\"1\":{\"49\":1}}],[\"具备自动调整堆内存大小的特点\",{\"1\":{\"50\":1}}],[\"关注的是系统的吞吐量\",{\"1\":{\"50\":1}}],[\"漏标等情况\",{\"1\":{\"49\":1}}],[\"重新标记\",{\"1\":{\"49\":1}}],[\"重排序时不能把后面的指令重排序到内存屏障之前的位置\",{\"1\":{\"15\":1}}],[\"商品接口等\",{\"1\":{\"49\":1}}],[\"频率高的场景\",{\"1\":{\"49\":1}}],[\"浮动垃圾问题\",{\"1\":{\"49\":1}}],[\"退化问题\",{\"1\":{\"49\":1}}],[\"退出代码块时刷新变量到主内存\",{\"1\":{\"19\":1}}],[\"允许同级之间委托进行类的加载\",{\"1\":{\"72\":1}}],[\"允许拓展java中比较通用的类\",{\"1\":{\"70\":1}}],[\"允许用户设置最大暂停时间\",{\"1\":{\"52\":1}}],[\"允许用户线程和垃圾回收线程在某些步骤中同时执行每减少了用户线程的等待时间\",{\"1\":{\"49\":1}}],[\"允许一个线程二次请求自己持有对象锁的临界资源\",{\"1\":{\"21\":1}}],[\"与parallel\",{\"1\":{\"51\":1}}],[\"与cms老年代垃圾回收器搭配使用\",{\"1\":{\"48\":1}}],[\"与serial垃圾回收器搭配使用\",{\"1\":{\"47\":1}}],[\"或者在cms特殊情况下使用\",{\"1\":{\"47\":1}}],[\"或者旧值为null\",{\"1\":{\"4\":1}}],[\"适用场景\",{\"1\":{\"46\":1,\"47\":1,\"50\":1,\"51\":1,\"52\":1}}],[\"多次回收过后\",{\"1\":{\"52\":1}}],[\"多线程并行回收\",{\"1\":{\"50\":1}}],[\"多cpu处理器下停顿时间较短\",{\"1\":{\"48\":1}}],[\"多cpu下吞吐量不如其他垃圾回收器\",{\"1\":{\"46\":1,\"47\":1}}],[\"多处理器结构\",{\"1\":{\"25\":1}}],[\"由类加载器子类实现\",{\"1\":{\"73\":1}}],[\"由于方法可能会在不同线程中执行\",{\"1\":{\"76\":1}}],[\"由于并发标记阶段有些对象会发生了变化\",{\"1\":{\"49\":1}}],[\"由于内存碎片的存在\",{\"1\":{\"41\":1}}],[\"由于内存是连续的\",{\"1\":{\"41\":1}}],[\"由程序员来选择灵活度较高\",{\"1\":{\"44\":1}}],[\"老年代\",{\"0\":{\"47\":1,\"49\":1,\"51\":1},\"1\":{\"47\":1,\"49\":1,\"51\":1}}],[\"老年代可以选择标记清除和标记整理算法\",{\"1\":{\"44\":1}}],[\"老年代中会存放长期存活的对象\",{\"1\":{\"44\":1}}],[\"新创建的对象会存放在eden区\",{\"1\":{\"52\":1}}],[\"新创建的对象已经无法放入\",{\"1\":{\"44\":1}}],[\"新生代一般选择复制算法\",{\"1\":{\"44\":1}}],[\"新生代和老年代使用不同的垃圾回收算法\",{\"1\":{\"44\":1}}],[\"新生代大小要远小于老年代的大小\",{\"1\":{\"44\":1}}],[\"订单数据返回给用户之后就可以释放了\",{\"1\":{\"44\":1}}],[\"系统由于垃圾回收出现的停顿时间较短\",{\"1\":{\"49\":1}}],[\"系统中的大部分对象\",{\"1\":{\"44\":1}}],[\"系统类加载器加载的java\",{\"1\":{\"34\":1}}],[\"为静态变量\",{\"1\":{\"64\":1}}],[\"为了节省空间\",{\"1\":{\"77\":1}}],[\"为了提高吞吐量\",{\"1\":{\"50\":1}}],[\"为了把二进制的各个位置都填上1\",{\"1\":{\"10\":1}}],[\"为什么分代gc算法要把堆分成年轻代和老年代\",{\"1\":{\"44\":1}}],[\"先进后出\",{\"1\":{\"76\":1}}],[\"先尝试minorgc如果还是不足\",{\"1\":{\"44\":1}}],[\"先将链表节点转换为树节点\",{\"1\":{\"12\":1}}],[\"初始化阶段会执行字节码文件中clinit部分的字节码指令\",{\"1\":{\"66\":1}}],[\"初始化阶段会执行静态代码块中的代码\",{\"1\":{\"66\":1}}],[\"初始化容量为16\",{\"1\":{\"10\":1}}],[\"初始化容量\",{\"0\":{\"10\":1}}],[\"初始标记\",{\"1\":{\"49\":1,\"52\":1}}],[\"初始值为0\",{\"1\":{\"44\":1}}],[\"把没有回收的对象放入to区\",{\"1\":{\"44\":1}}],[\"把哈希值右移\",{\"1\":{\"9\":1}}],[\"首先会被放入eden伊甸园区\",{\"1\":{\"44\":1}}],[\"首先判断table是否为空以及其长度是否大于0\",{\"1\":{\"5\":1}}],[\"创建出来的对象都存在与堆上\",{\"1\":{\"81\":1}}],[\"创建出来的对象\",{\"1\":{\"44\":1}}],[\"创建一个新的哈希数组\",{\"1\":{\"7\":1}}],[\"区域不要求是连续的\",{\"1\":{\"52\":1}}],[\"区\",{\"1\":{\"44\":1}}],[\"存在错标\",{\"1\":{\"49\":1}}],[\"存在循环引用问题\",{\"1\":{\"33\":1}}],[\"存放存活时间比较长的对象\",{\"1\":{\"44\":1}}],[\"存放存活时间比较短的对象\",{\"1\":{\"44\":1}}],[\"分配内存并设置初始值\",{\"1\":{\"64\":1}}],[\"分配速度慢\",{\"1\":{\"41\":1}}],[\"分为eden\",{\"1\":{\"52\":1}}],[\"分代的设计中允许只回收新生代\",{\"1\":{\"44\":1}}],[\"分代回收时\",{\"1\":{\"44\":1}}],[\"分代垃圾回收会将整个区域划分为年轻代\",{\"1\":{\"44\":1}}],[\"分代垃圾回收算法⭐\",{\"0\":{\"44\":1}}],[\"清空这些区域\",{\"1\":{\"52\":1}}],[\"清理死亡的对象\",{\"1\":{\"49\":1}}],[\"清理掉存活对象的内存空间\",{\"1\":{\"43\":1}}],[\"清除阶段\",{\"1\":{\"41\":1}}],[\"整理阶段的效率不高\",{\"1\":{\"43\":1}}],[\"整理阶段\",{\"1\":{\"43\":1}}],[\"优缺点\",{\"1\":{\"42\":1,\"43\":1}}],[\"优点\",{\"1\":{\"33\":1,\"41\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1}}],[\"回收时会影响对象的创建和使用\",{\"1\":{\"83\":1}}],[\"回收所有年轻代和部分老年代的对象以及大对象区\",{\"1\":{\"52\":1}}],[\"回收eden区和survivor区中不用的对象\",{\"1\":{\"52\":1}}],[\"回收算法\",{\"1\":{\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1}}],[\"回收年代\",{\"1\":{\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1}}],[\"回收to空间中的对象\",{\"1\":{\"42\":1}}],[\"回收软引用中的对象\",{\"1\":{\"36\":1}}],[\"found\",{\"1\":{\"84\":1}}],[\"forname\",{\"1\":{\"66\":1}}],[\"form\",{\"1\":{\"44\":1}}],[\"frame\",{\"1\":{\"76\":1}}],[\"from空间\",{\"1\":{\"42\":1}}],[\"fullgc\",{\"1\":{\"44\":1}}],[\"fullgc会对整个堆进行垃圾回收\",{\"1\":{\"44\":1}}],[\"findclass\",{\"1\":{\"73\":1}}],[\"final修饰的基本数据类型的静态变量\",{\"1\":{\"64\":1}}],[\"finally\",{\"1\":{\"28\":1}}],[\"final\",{\"1\":{\"9\":1,\"10\":1,\"55\":1,\"73\":2}}],[\"first\",{\"1\":{\"52\":1,\"76\":1}}],[\"fifo\",{\"1\":{\"25\":1}}],[\"只需要访问堆中的class对象而不需要访问方法区中所有信息\",{\"1\":{\"61\":1}}],[\"只需要在第一阶段给每个对象维护标志位\",{\"1\":{\"41\":1}}],[\"只不过survivor区中存活对象会被搬运到另一个survivor区\",{\"1\":{\"52\":1}}],[\"只能使用其中一块空间\",{\"1\":{\"42\":1}}],[\"核心思想\",{\"1\":{\"42\":1,\"43\":1}}],[\"核心思想分为两个阶段\",{\"1\":{\"41\":1}}],[\"复制算法\",{\"0\":{\"42\":1},\"1\":{\"46\":1,\"48\":1,\"50\":1,\"52\":1}}],[\"极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间\",{\"1\":{\"41\":1}}],[\"需要先把文件读入直接内存\",{\"1\":{\"83\":1}}],[\"需要存储此方法出口的地址\",{\"1\":{\"79\":1}}],[\"需要将符号引用\",{\"1\":{\"79\":1}}],[\"需要重新标记\",{\"1\":{\"49\":1}}],[\"需要维护一个空闲链表\",{\"1\":{\"41\":1}}],[\"需要同时满足下面三个条件\",{\"1\":{\"31\":1}}],[\"很有可能这些内存单元的大小过小无法进行分配\",{\"1\":{\"41\":1}}],[\"碎片化问题\",{\"1\":{\"41\":1}}],[\"标记出eden和survivor区域中的存活对象\",{\"1\":{\"52\":1}}],[\"标记所有的对象\",{\"1\":{\"49\":1}}],[\"标记整理算法\",{\"0\":{\"43\":1},\"1\":{\"47\":1,\"51\":1}}],[\"标记阶段\",{\"1\":{\"41\":1,\"43\":1}}],[\"标记清除算法\",{\"0\":{\"41\":1},\"1\":{\"49\":1}}],[\"标记清楚算法要优于复制算法\",{\"1\":{\"40\":1}}],[\"从内存中删除没有被标记也就是非存活对象\",{\"1\":{\"41\":1}}],[\"从gcroot开始通过引用链遍历出所有存活对象\",{\"1\":{\"41\":1,\"43\":1}}],[\"从堆使用效率上来说\",{\"1\":{\"40\":1}}],[\"从而在执行时正确的分配内存大小\",{\"1\":{\"78\":1}}],[\"从而回收内存\",{\"1\":{\"38\":1}}],[\"从而使用共享变量时从主内存中重新读取最新的值\",{\"1\":{\"19\":1}}],[\"比如urlclassloader会根据文件路径去获取类文件中的二进制数据\",{\"1\":{\"73\":1}}],[\"比如jdbc和jndi等\",{\"1\":{\"72\":1}}],[\"比如方法内的指令执行到一半强行跳转到其他方法中去\",{\"1\":{\"63\":1}}],[\"比如文件是否以0xcafebabe开头\",{\"1\":{\"63\":1}}],[\"比如源码的文件名\",{\"1\":{\"58\":1}}],[\"比如\",{\"1\":{\"50\":1,\"82\":1}}],[\"比如订单接口\",{\"1\":{\"49\":1}}],[\"比如spring的大部分bean对象\",{\"1\":{\"44\":1}}],[\"比如用户获取订单数据\",{\"1\":{\"44\":1}}],[\"比如标记清除算法\",{\"1\":{\"40\":1}}],[\"比如你希望用更多的空间换取时间\",{\"1\":{\"11\":1}}],[\"堆空间有三个需要关注的值\",{\"1\":{\"81\":1}}],[\"堆\",{\"0\":{\"81\":1}}],[\"堆如果偏大会让用户线程处于长时间的等待\",{\"1\":{\"46\":1,\"47\":1}}],[\"堆使用效率\",{\"1\":{\"40\":1}}],[\"堆回收\",{\"0\":{\"32\":1}}],[\"吞吐量和停顿时间不如g1\",{\"1\":{\"48\":1}}],[\"吞吐量高\",{\"1\":{\"42\":1,\"50\":1}}],[\"吞吐量数值越高\",{\"1\":{\"40\":1}}],[\"吞吐量指的是cpu用来执行用户代码的时间与cpu总执行时间的比值\",{\"1\":{\"40\":1}}],[\"吞吐量\",{\"1\":{\"40\":1}}],[\"评价标准\",{\"0\":{\"40\":1}}],[\"人如果stw时间过长则会影响用户的使用\",{\"1\":{\"39\":1}}],[\"人防资料管理平台项目难点\",{\"1\":{\"1\":1}}],[\"world简称stw\",{\"1\":{\"39\":1}}],[\"使得程序能再次利用这部分空间\",{\"1\":{\"39\":1}}],[\"使用了直接内存\",{\"1\":{\"83\":1}}],[\"使用了虚引用来实现\",{\"1\":{\"38\":1}}],[\"使用spi机制+线程上下文加载器\",{\"1\":{\"72\":1}}],[\"使用\",{\"1\":{\"53\":1,\"60\":1}}],[\"使用场景\",{\"1\":{\"48\":1,\"49\":1}}],[\"使用多线程进行垃圾回收\",{\"1\":{\"48\":1}}],[\"使用起来更加灵活\",{\"1\":{\"28\":1}}],[\"释放不再存活对象的内存\",{\"1\":{\"39\":1}}],[\"找到内存中存活的对象\",{\"1\":{\"39\":1}}],[\"幻影引用\",{\"1\":{\"38\":1}}],[\"该软引用对象会被放入引用队列\",{\"1\":{\"36\":1}}],[\"该类对应的java\",{\"1\":{\"31\":1}}],[\"通过静态变量就可以实现对象在线程之间共享\",{\"1\":{\"81\":1}}],[\"通过thread\",{\"1\":{\"72\":1}}],[\"通过加载字节码数据放入内存转换成byte\",{\"1\":{\"67\":1}}],[\"通过代码遍历引用队列\",{\"1\":{\"36\":1}}],[\"通过构造器传入引用队列\",{\"1\":{\"36\":1}}],[\"通过reentrantlock的构造函数确认在创建时是否初始化公平锁判断公平锁\",{\"1\":{\"23\":1}}],[\"抛出outofmemory异常\",{\"1\":{\"36\":1}}],[\"虚拟机底层实现\",{\"0\":{\"69\":1}}],[\"虚拟机会动态调整堆的参数\",{\"1\":{\"50\":1}}],[\"虚拟机尝试进行垃圾回收\",{\"1\":{\"36\":1}}],[\"虚引用唯一的用途是在当对象被垃圾回收器回收时可以接收到对应的通知\",{\"1\":{\"38\":1}}],[\"虚引用也叫幽灵引用\",{\"1\":{\"38\":1}}],[\"虚引用和终结器引用\",{\"0\":{\"38\":1}}],[\"虚引用\",{\"1\":{\"35\":1}}],[\"终结器引用指的是在对象需要被回收时\",{\"1\":{\"38\":1}}],[\"终结器引用\",{\"1\":{\"35\":1}}],[\"弱引用对象本身也可以使用引用队列进行回收\",{\"1\":{\"37\":1}}],[\"弱引用主要在threadloacl中使用\",{\"1\":{\"37\":1}}],[\"弱引用包含的对象在垃圾回收时\",{\"1\":{\"37\":1}}],[\"弱引用\",{\"0\":{\"37\":1},\"1\":{\"35\":1}}],[\"强引用\",{\"1\":{\"35\":1}}],[\"普通对象就不会被回收\",{\"1\":{\"35\":1}}],[\"这种常量池称为运行时常量池\",{\"1\":{\"82\":1}}],[\"这种常量池称为静态常量池\",{\"1\":{\"82\":1}}],[\"这类变量会在准备阶段直接进行初始化\",{\"1\":{\"66\":1}}],[\"这类老年代被称为humongous区\",{\"1\":{\"52\":1}}],[\"这样不会破坏双亲委派机制\",{\"1\":{\"73\":1}}],[\"这样java虚拟机就能很好地控制开发者访问数据的范围\",{\"1\":{\"61\":1}}],[\"这样就混合了原哈希值中的高位和低位\",{\"1\":{\"9\":1}}],[\"这也是g1名称的由来\",{\"1\":{\"52\":1}}],[\"这个123就会被放入字符串常量池\",{\"1\":{\"82\":1}}],[\"这个阶段一般不需要程序员参与\",{\"1\":{\"63\":1}}],[\"这个可以保证回收效率最高\",{\"1\":{\"52\":1}}],[\"这个过程被称之为stop\",{\"1\":{\"39\":1}}],[\"这要这层关系存在\",{\"1\":{\"35\":1}}],[\"监视器对象\",{\"1\":{\"34\":1}}],[\"引用类中的静态变量\",{\"1\":{\"34\":1}}],[\"引用线程栈帧中的方法参数\",{\"1\":{\"34\":1}}],[\"引用计数器会为每个对象维护一个引用计数器\",{\"1\":{\"33\":1}}],[\"引用计数器\",{\"0\":{\"33\":1},\"1\":{\"32\":1}}],[\"getcontextclassloader\",{\"1\":{\"72\":1}}],[\"get流程\",{\"0\":{\"5\":1}}],[\"g1对老年代的清理会选择存活度最低的区域来进行回收\",{\"1\":{\"52\":1}}],[\"g1在进行young\",{\"1\":{\"52\":1}}],[\"g1的整个堆会被划分成多个大小相等的区域\",{\"1\":{\"52\":1}}],[\"g1垃圾回收器\",{\"0\":{\"52\":1}}],[\"garbage\",{\"1\":{\"52\":1}}],[\"gc的过程中会去记录每次垃圾回收时每个eden区和survivor区的平均耗时\",{\"1\":{\"52\":1}}],[\"gc时与之前相同\",{\"1\":{\"52\":1}}],[\"gc时间\",{\"1\":{\"40\":1}}],[\"gc\",{\"1\":{\"52\":3}}],[\"gcroot对象\",{\"1\":{\"34\":1}}],[\"gcroot\",{\"1\":{\"34\":1}}],[\"垃圾回收方式\",{\"1\":{\"52\":1}}],[\"垃圾回收器\",{\"0\":{\"45\":1,\"49\":1},\"1\":{\"52\":1}}],[\"垃圾回收的效率就越高\",{\"1\":{\"40\":1}}],[\"垃圾回收的根对象\",{\"1\":{\"34\":1}}],[\"垃圾回收要做两件事\",{\"1\":{\"39\":1}}],[\"垃圾回收算法\",{\"0\":{\"39\":1}}],[\"垃圾回收机制\",{\"0\":{\"30\":1}}],[\"对于开发者来说\",{\"1\":{\"61\":1}}],[\"对比较大的堆如超过6g的堆回收时\",{\"1\":{\"52\":1}}],[\"对堆内存的使用方式是不同的\",{\"1\":{\"40\":1}}],[\"对象就会被晋升至老年代\",{\"1\":{\"44\":1}}],[\"对象就不可被回收\",{\"1\":{\"34\":1}}],[\"对象将会被放置在finalizer类中的引用队列中\",{\"1\":{\"38\":1}}],[\"对象\",{\"1\":{\"36\":1}}],[\"对象引用方式\",{\"1\":{\"35\":1}}],[\"对象引用\",{\"0\":{\"35\":1}}],[\"对象与对象之间存在引用关系\",{\"1\":{\"34\":1}}],[\"对系统性能会有一定的影响\",{\"1\":{\"33\":1}}],[\"对称\",{\"1\":{\"25\":1}}],[\"缺点\",{\"1\":{\"33\":1,\"41\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1}}],[\"判定一个类可以被卸载\",{\"1\":{\"31\":1}}],[\"判断当前线程是否是同步队列的首位\",{\"1\":{\"23\":1}}],[\"判断哈希数组是否已经初始化\",{\"1\":{\"7\":1}}],[\"方式\",{\"1\":{\"72\":1}}],[\"方法会把第一次遇到的字符串的引用放入字符串常量池\",{\"1\":{\"82\":1}}],[\"方法出口指的是方法在正确或者异常结束时\",{\"1\":{\"79\":1}}],[\"方法体中声明的局部变量\",{\"1\":{\"77\":1}}],[\"方法的参数\",{\"1\":{\"77\":1}}],[\"方法参数也会保存在局部变量表中\",{\"1\":{\"77\":1}}],[\"方法\",{\"0\":{\"58\":1},\"1\":{\"54\":1}}],[\"方法区是用来存储每个类的基本信息\",{\"1\":{\"82\":1}}],[\"方法区时存放基础信息的位置\",{\"1\":{\"82\":1}}],[\"方法区\",{\"0\":{\"82\":1}}],[\"方法区中能回收的内容主要就是不再使用的类\",{\"1\":{\"31\":1}}],[\"方法区的回收\",{\"0\":{\"31\":1}}],[\"方便后续树转链表和拆分\",{\"1\":{\"12\":1}}],[\"少等待的线程中\",{\"1\":{\"28\":1}}],[\"里面还包含实现特定功能比如多态的信息\",{\"1\":{\"61\":1}}],[\"里面\",{\"1\":{\"28\":1}}],[\"同时java堆上维护直接内存的引用\",{\"1\":{\"83\":1}}],[\"同时程序计数器应该指向上一个栈帧中的下一条指令的地址\",{\"1\":{\"79\":1}}],[\"同时\",{\"1\":{\"61\":1}}],[\"同时不要将获取锁的过程写在\",{\"1\":{\"28\":1}}],[\"同时记录链表的顺序\",{\"1\":{\"12\":1}}],[\"最终标记\",{\"1\":{\"52\":1}}],[\"最终能够被释放\",{\"1\":{\"28\":1}}],[\"最大15\",{\"1\":{\"44\":1}}],[\"最大暂停时间越短\",{\"1\":{\"40\":1}}],[\"最大暂停时间指的是所有再垃圾回收过程中的stw时间最大值\",{\"1\":{\"40\":1}}],[\"最大暂停时间\",{\"1\":{\"40\":1}}],[\"最后把结果加\",{\"1\":{\"10\":1}}],[\"总结\",{\"0\":{\"28\":1}}],[\"中引入了nio机制\",{\"1\":{\"83\":1}}],[\"中存在\",{\"1\":{\"83\":1}}],[\"中的约束\",{\"1\":{\"63\":1}}],[\"中的队列是\",{\"1\":{\"25\":1}}],[\"中释放锁\",{\"1\":{\"28\":1}}],[\"中使用\",{\"1\":{\"27\":1}}],[\"中设置拥有者的号牌\",{\"1\":{\"27\":1}}],[\"代码实现上也比较简单\",{\"1\":{\"27\":1}}],[\"统性能\",{\"1\":{\"27\":1}}],[\"非常消耗系\",{\"1\":{\"27\":1}}],[\"每一个方法的调用使用一个栈帧\",{\"1\":{\"76\":1}}],[\"每个线程都会包含一个自己的虚拟机栈\",{\"1\":{\"76\":1}}],[\"每个线程会通过程序计数器记录当前要执行的字节码指令的地址\",{\"1\":{\"75\":1}}],[\"每个类加载器都会先检查是否已经加载了该类\",{\"1\":{\"71\":1}}],[\"每个类加载器都有一个父类加载器\",{\"1\":{\"71\":1}}],[\"每个进程\",{\"1\":{\"27\":1}}],[\"每次gc完加1\",{\"1\":{\"44\":1}}],[\"每次minorgc都会为对象记录他的年龄\",{\"1\":{\"44\":1}}],[\"每次在对象分配阶段\",{\"1\":{\"42\":1}}],[\"每次只能使用一半内存\",{\"1\":{\"40\":1}}],[\"每次引用和取消引用都需要维护计数器\",{\"1\":{\"33\":1}}],[\"每次读写操作都需要进行多处理间的缓存同步\",{\"1\":{\"27\":1}}],[\"叫到你号你才能进去\",{\"1\":{\"27\":1}}],[\"呷哺给你的一个排号卡一样\",{\"1\":{\"27\":1}}],[\"就可以将双亲委派机制的代码去除\",{\"1\":{\"72\":1}}],[\"就会触发fullgc\",{\"1\":{\"44\":1}}],[\"就会触发年轻代的gc\",{\"1\":{\"44\":1}}],[\"就会将软引用中的数据进行回收\",{\"1\":{\"36\":1}}],[\"就像你去银行\",{\"1\":{\"27\":1}}],[\"就是一个标准的2的倍数减1了\",{\"1\":{\"10\":1}}],[\"而本地方法栈存储的是native本地方法的栈帧\",{\"1\":{\"80\":1}}],[\"而回收则会在线程的销毁时进行\",{\"1\":{\"76\":1}}],[\"而是使用内存中的地址进行访问具体的数据\",{\"1\":{\"73\":1}}],[\"而且手动可控\",{\"1\":{\"50\":1}}],[\"而复制算法会将堆内存一分为二\",{\"1\":{\"40\":1}}],[\"而\",{\"1\":{\"26\":1}}],[\"而它的可重入是因为实现了同步器\",{\"1\":{\"22\":1}}],[\"添加这个真实节点后\",{\"1\":{\"26\":1}}],[\"它就可以只在本地变量上自旋\",{\"1\":{\"26\":1}}],[\"它是真的有下一个节点\",{\"1\":{\"26\":1}}],[\"它所提供的共享锁\",{\"1\":{\"22\":1}}],[\"但是没有赋值语句\",{\"1\":{\"66\":1}}],[\"但是不管使用哪一种gc算法\",{\"1\":{\"39\":1}}],[\"但是不建议这样做\",{\"1\":{\"38\":1}}],[\"但是多处理器系统上\",{\"1\":{\"27\":1}}],[\"但一定要在\",{\"1\":{\"28\":1}}],[\"但与\",{\"1\":{\"26\":1}}],[\"但在\",{\"1\":{\"25\":1}}],[\"高性能\",{\"1\":{\"26\":1}}],[\"下效果就不太好了\",{\"1\":{\"25\":1}}],[\"效果还是不错的\",{\"1\":{\"25\":1}}],[\"out\",{\"1\":{\"76\":1}}],[\"off\",{\"1\":{\"73\":1}}],[\"osgi框架的类加载器\",{\"1\":{\"72\":1}}],[\"old区\",{\"1\":{\"52\":1}}],[\"old是为parallel\",{\"1\":{\"51\":1}}],[\"old垃圾回收器\",{\"0\":{\"51\":1}}],[\"o\",{\"1\":{\"25\":1}}],[\"object\",{\"1\":{\"9\":1}}],[\"组成\",{\"1\":{\"25\":1}}],[\"一旦某个局部变量不再生效\",{\"1\":{\"77\":1}}],[\"一类是java虚拟机底层源码实现的\",{\"1\":{\"68\":1}}],[\"一类是java代码实现的\",{\"1\":{\"68\":1}}],[\"一般称之为instanceklass对象\",{\"1\":{\"82\":1}}],[\"一般java程序中堆内存时空间最大的一块内存区域\",{\"1\":{\"81\":1}}],[\"一般只需关注主版本号\",{\"1\":{\"55\":1}}],[\"一般指的是强引用\",{\"1\":{\"35\":1}}],[\"一般会用在较\",{\"1\":{\"28\":1}}],[\"一台计算机由多个\",{\"1\":{\"25\":1}}],[\"一个操作是不可中断的\",{\"1\":{\"18\":1}}],[\"method\",{\"0\":{\"82\":1}}],[\"memory\",{\"0\":{\"83\":1},\"1\":{\"25\":1}}],[\"mixed\",{\"1\":{\"52\":1}}],[\"minorgc\",{\"1\":{\"44\":1}}],[\"minorgc会把需要eden中和from选哟回收的对象回收\",{\"1\":{\"44\":1}}],[\"machine\",{\"0\":{\"76\":1}}],[\"magic\",{\"1\":{\"55\":1}}],[\"max是java虚拟机可以分配的最大堆内存\",{\"1\":{\"81\":1}}],[\"max\",{\"1\":{\"81\":1}}],[\"max默认60\",{\"1\":{\"52\":1}}],[\"maximum\",{\"1\":{\"10\":2}}],[\"mark\",{\"0\":{\"49\":1}}],[\"mcs也是一种基于链表的可扩展\",{\"1\":{\"26\":1}}],[\"mcs\",{\"0\":{\"26\":1}}],[\"multi\",{\"1\":{\"25\":1}}],[\"队列锁的优点是空间复杂度低\",{\"1\":{\"25\":1}}],[\"变体的虚拟双向队\",{\"1\":{\"25\":1}}],[\"公平的自旋锁\",{\"1\":{\"25\":1,\"26\":1}}],[\"公平锁的实现依据不同场景和\",{\"1\":{\"28\":1}}],[\"公平锁实现\",{\"0\":{\"24\":1}}],[\"公平锁\",{\"0\":{\"23\":1}}],[\"的使用\",{\"1\":{\"28\":1}}],[\"的两个实现类中\",{\"1\":{\"22\":1}}],[\"的操作\",{\"1\":{\"22\":1}}],[\"互斥锁都是基于对\",{\"1\":{\"22\":1}}],[\"时\",{\"1\":{\"22\":1}}],[\"时间\",{\"1\":{\"1\":1}}],[\"各自维护不同的对象\",{\"1\":{\"22\":1}}],[\"counter\",{\"0\":{\"75\":1}}],[\"concurrent\",{\"0\":{\"49\":1}}],[\"condition\",{\"1\":{\"22\":2}}],[\"c\",{\"1\":{\"73\":1}}],[\"currentthread\",{\"1\":{\"72\":1}}],[\"c++\",{\"1\":{\"69\":1}}],[\"cms执行步骤\",{\"1\":{\"49\":1}}],[\"cms垃圾回收器关注的是系统的暂停时间\",{\"1\":{\"49\":1}}],[\"cms\",{\"0\":{\"49\":1}}],[\"clinit指令在特定情况下不会出现\",{\"1\":{\"66\":1}}],[\"class<\",{\"1\":{\"73\":4}}],[\"classloader\",{\"0\":{\"67\":1}}],[\"classname\",{\"1\":{\"66\":1}}],[\"class对象\",{\"1\":{\"34\":1,\"61\":1}}],[\"class对象没有在任何地方被引用\",{\"1\":{\"31\":1}}],[\"clh\",{\"0\":{\"25\":1},\"1\":{\"25\":3,\"26\":2}}],[\"caution\",{\"1\":{\"52\":1}}],[\"cas\",{\"1\":{\"27\":1}}],[\"capacity\",{\"1\":{\"10\":2}}],[\"cap\",{\"1\":{\"10\":2}}],[\"cpu\",{\"1\":{\"25\":2}}],[\"和老年代\",{\"1\":{\"44\":1}}],[\"和普通对象\",{\"1\":{\"34\":1}}],[\"和外部中断\",{\"1\":{\"25\":1}}],[\"和\",{\"1\":{\"22\":2}}],[\"实例方法的this对象\",{\"1\":{\"77\":1}}],[\"实现分支\",{\"1\":{\"75\":1}}],[\"实现简单\",{\"1\":{\"33\":1,\"41\":1}}],[\"实现的可重入锁\",{\"1\":{\"22\":1,\"28\":1}}],[\"实\",{\"1\":{\"22\":1}}],[\"area\",{\"0\":{\"82\":1}}],[\"arthas\",{\"1\":{\"53\":1}}],[\"application\",{\"1\":{\"70\":1}}],[\"access\",{\"1\":{\"25\":1}}],[\"aqs\",{\"0\":{\"29\":1},\"1\":{\"22\":2,\"25\":2}}],[\"as\",{\"1\":{\"20\":1}}],[\"都是创建出来之后很快就不再使用可以被回收\",{\"1\":{\"44\":1}}],[\"都是基于\",{\"1\":{\"22\":1}}],[\"都会有部分阶段需要停止所有的用户线程\",{\"1\":{\"39\":1}}],[\"都可以平等地访问内存\",{\"1\":{\"25\":1}}],[\"都需要保证单线程下的运行结果的正确性\",{\"1\":{\"20\":1}}],[\"锁对象有个计数器\",{\"1\":{\"21\":1}}],[\"是否兼容\",{\"1\":{\"55\":1}}],[\"是否存在\",{\"1\":{\"23\":1}}],[\"是根据对象是否被引用来决定的\",{\"1\":{\"32\":1}}],[\"是前驱节点的属性上自旋\",{\"1\":{\"26\":1}}],[\"是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配\",{\"1\":{\"25\":1}}],[\"是一种基于单向链表的高性能\",{\"1\":{\"25\":1}}],[\"是一个默认构造值\",{\"1\":{\"11\":1}}],[\"是基于\",{\"1\":{\"22\":1,\"28\":1}}],[\"是因为synchronized\",{\"1\":{\"21\":1}}],[\"之所以是可以重入\",{\"1\":{\"21\":1}}],[\"之后与原哈希值做异或运算\",{\"1\":{\"9\":1}}],[\"所以并不属于java运行时的内存区域\",{\"1\":{\"83\":1}}],[\"所以看上去是自顶向下尝试加载\",{\"1\":{\"71\":1}}],[\"所以尽量保证该应用的堆内存有一定多余的空间\",{\"1\":{\"52\":1}}],[\"所以在当前栈帧中\",{\"1\":{\"79\":1}}],[\"所以在jdk9之后不建议使用\",{\"1\":{\"48\":1}}],[\"所以在对象被删除之后\",{\"1\":{\"41\":1}}],[\"所以只需要将树节点转换为链表节点\",{\"1\":{\"13\":1}}],[\"所谓循环引用就是当a引用b\",{\"1\":{\"33\":1}}],[\"所有intern\",{\"1\":{\"82\":1}}],[\"所有的\",{\"1\":{\"22\":1,\"25\":1}}],[\"所有操作都是无序的\",{\"1\":{\"20\":1}}],[\"所有操作都是有序的\",{\"1\":{\"20\":1}}],[\"io操作比如读文件\",{\"1\":{\"83\":1}}],[\"in\",{\"1\":{\"76\":1}}],[\"int\",{\"1\":{\"9\":2,\"10\":3,\"73\":2}}],[\"i\",{\"1\":{\"25\":1}}],[\"if\",{\"1\":{\"20\":1}}],[\"相当于jmm中的lock\",{\"1\":{\"19\":1}}],[\"必须把共享变量的最新值刷新到主内存中\",{\"1\":{\"19\":1}}],[\"可以通过内存地址快速得定位到常量池中的内容\",{\"1\":{\"82\":1}}],[\"可以通过调整年轻代和老年代的比例来适应不同类型的应用程序\",{\"1\":{\"44\":1}}],[\"可以存放对上对象的引用\",{\"1\":{\"81\":1}}],[\"可以使用完整的堆内存\",{\"1\":{\"40\":1}}],[\"可以把负载因子调的更小一些\",{\"1\":{\"11\":1}}],[\"可达性算法中描述的对象引用\",{\"1\":{\"35\":1}}],[\"可达性分析将对象分为两类\",{\"1\":{\"34\":1}}],[\"可达性分析算法指如果某个到gc\",{\"1\":{\"34\":1}}],[\"可达性分析算法\",{\"0\":{\"34\":1}}],[\"可达性分析法\",{\"1\":{\"32\":1}}],[\"可操作性也更大\",{\"1\":{\"28\":1}}],[\"可重入性\",{\"0\":{\"21\":1}}],[\"可见性\",{\"0\":{\"19\":1}}],[\"要么全部执行成功要么全部执行失败\",{\"1\":{\"18\":1}}],[\"原子性\",{\"0\":{\"18\":1}}],[\"特性\",{\"0\":{\"17\":1}}],[\"slot\",{\"1\":{\"77\":1}}],[\"super不能为空\",{\"1\":{\"63\":1}}],[\"survivor\",{\"1\":{\"52\":1}}],[\"size必须是2的指数幂\",{\"1\":{\"52\":1}}],[\"scavenge与cms的优点融合\",{\"1\":{\"52\":1}}],[\"scavenge配套使用\",{\"1\":{\"51\":1}}],[\"scavenge收集器设计的老年代版本\",{\"1\":{\"51\":1}}],[\"scavenge是jdk8默认的年轻代垃圾回收器\",{\"1\":{\"50\":1}}],[\"scavenge垃圾回收器\",{\"0\":{\"50\":1}}],[\"sweep\",{\"0\":{\"49\":1}}],[\"stack\",{\"0\":{\"76\":1},\"1\":{\"76\":1}}],[\"state\",{\"1\":{\"22\":1}}],[\"static\",{\"1\":{\"9\":1,\"10\":1,\"64\":1}}],[\"string\",{\"1\":{\"66\":1,\"73\":3}}],[\"stw时间就会减少\",{\"1\":{\"44\":1}}],[\"s1\",{\"1\":{\"44\":1}}],[\"s0\",{\"1\":{\"44\":1}}],[\"softreference提供了一套队列机制\",{\"1\":{\"36\":1}}],[\"softreference<对象类型>\",{\"1\":{\"36\":1}}],[\"symmetric\",{\"1\":{\"25\":1}}],[\"sync\",{\"1\":{\"22\":2}}],[\"synchronized靠操作系统内存互斥锁实现\",{\"1\":{\"19\":1}}],[\"synchronized\",{\"0\":{\"16\":1}}],[\"smp\",{\"1\":{\"25\":1,\"28\":1}}],[\"serialold是serial垃圾回收器的老年代版本\",{\"1\":{\"47\":1}}],[\"serialold垃圾回收器\",{\"0\":{\"47\":1}}],[\"serial是一种单线程串行回收年轻代的垃圾回收器\",{\"1\":{\"46\":1}}],[\"serial垃圾回收器\",{\"0\":{\"46\":1}}],[\"serial\",{\"1\":{\"20\":1}}],[\"防止指令重排序\",{\"1\":{\"15\":1}}],[\"将常量池中的符号引用替换成指向内存的直接引用\",{\"1\":{\"62\":1}}],[\"将文件头称为魔数\",{\"1\":{\"55\":1}}],[\"将parallel\",{\"1\":{\"52\":1}}],[\"将存活对象移动到堆的一端\",{\"1\":{\"43\":1}}],[\"将两块空间的from和to名字互换\",{\"1\":{\"42\":1}}],[\"将from中存活对象复制到to空间\",{\"1\":{\"42\":1}}],[\"将所有存活的对象进行标记\",{\"1\":{\"41\":1,\"43\":1}}],[\"将softreference的强引用删除\",{\"1\":{\"36\":1}}],[\"将对象使用软引用包装起来\",{\"1\":{\"36\":1}}],[\"将清空工作内存中共享变量的值\",{\"1\":{\"19\":1}}],[\"将本处理器的缓存写入内存\",{\"1\":{\"15\":1}}],[\"将各个元素的hash值与旧的容量进行\",{\"1\":{\"8\":1}}],[\"会自底向上查找是否加载过\",{\"1\":{\"71\":1}}],[\"会先调用父类的clinit初始化方法\",{\"1\":{\"66\":1}}],[\"会出现fullgc\",{\"1\":{\"52\":1}}],[\"会出现很多old老年代区\",{\"1\":{\"52\":1}}],[\"会直接放入老年代\",{\"1\":{\"52\":1}}],[\"会被放入老年代\",{\"1\":{\"52\":1}}],[\"会导致stw\",{\"1\":{\"52\":1}}],[\"会有不同的优劣效果\",{\"1\":{\"28\":1}}],[\"会随着线程获取锁+1计数\",{\"1\":{\"21\":1}}],[\"会在jmm中通过添加lock指令来保证\",{\"1\":{\"15\":1}}],[\"会根据tablesizefor计算出最接近的容量进行设置\",{\"1\":{\"10\":1}}],[\"用极短的时间标记出gcroot能直接关联到的对象\",{\"1\":{\"49\":1}}],[\"用户线程不需要暂停\",{\"1\":{\"49\":2}}],[\"用户体验好\",{\"1\":{\"49\":1}}],[\"用户使用系统时受到的影响就越短\",{\"1\":{\"40\":1}}],[\"用来保存同步锁synchronized关键字持有的对象\",{\"1\":{\"34\":1}}],[\"用来修饰变量\",{\"1\":{\"15\":1}}],[\"用于优化散列效果\",{\"1\":{\"9\":1}}],[\"virtual\",{\"0\":{\"76\":1}}],[\"void\",{\"1\":{\"73\":1}}],[\"volatile的可见性都是通过内存屏障来实现的\",{\"1\":{\"19\":1}}],[\"volatile不能解决原子性\",{\"1\":{\"15\":1}}],[\"volatile关键字是java虚拟机提供的最轻量级的同步机制\",{\"1\":{\"15\":1}}],[\"volatile\",{\"0\":{\"15\":1}}],[\"v\",{\"1\":{\"53\":1}}],[\"value\",{\"1\":{\"3\":1}}],[\"红黑树转链\",{\"0\":{\"13\":1}}],[\"过程\",{\"1\":{\"12\":1}}],[\"不影响文件的内容\",{\"1\":{\"55\":1}}],[\"不需要与用户交互\",{\"1\":{\"50\":1}}],[\"不能保证单次的停顿时间\",{\"1\":{\"50\":1}}],[\"不能通过虚引用对象获取到包含的对象\",{\"1\":{\"38\":1}}],[\"不会触发子类的初始化\",{\"1\":{\"66\":1}}],[\"不会产生内存碎片\",{\"1\":{\"52\":1}}],[\"不会发生碎片化\",{\"1\":{\"42\":1,\"43\":1}}],[\"不会树化\",{\"1\":{\"12\":1}}],[\"不管内存够不够都会直接被回收\",{\"1\":{\"37\":1}}],[\"不同的垃圾回收算法\",{\"1\":{\"40\":1}}],[\"不同\",{\"1\":{\"26\":1}}],[\"不使用concurrenthashmap如何确保hashmap线程安全\",{\"1\":{\"1\":1}}],[\"数组中每一个位置称之为槽\",{\"1\":{\"77\":1}}],[\"数组的创建不会导致数组中元素的类进行初始化\",{\"1\":{\"66\":1}}],[\"数组容量大于64\",{\"1\":{\"12\":1}}],[\"数据迁移\",{\"0\":{\"8\":1}}],[\"数据结构\",{\"0\":{\"3\":1}}],[\"条件\",{\"1\":{\"12\":1}}],[\"也可以调整\",{\"1\":{\"11\":1}}],[\"也就正好是自己长度的一半\",{\"1\":{\"9\":1}}],[\"75\",{\"1\":{\"11\":1}}],[\"当常量池加载到内存中之后\",{\"1\":{\"82\":1}}],[\"当total可以使用的内存即将不足时\",{\"1\":{\"81\":1}}],[\"当前栈帧会被弹出\",{\"1\":{\"79\":1}}],[\"当前类的字节码指令引用了其他类的属性或方法时\",{\"1\":{\"79\":1}}],[\"当前类或接口声明的方法信息字节码指令\",{\"1\":{\"58\":1}}],[\"当前类或接口声明的字段信息\",{\"1\":{\"57\":1}}],[\"当前槽就可以再次被使用\",{\"1\":{\"77\":1}}],[\"当一个类加载器接收到加载类的任务时\",{\"1\":{\"71\":1}}],[\"当某个存活对象的年龄达到阈值\",{\"1\":{\"52\":1}}],[\"当g1判断年轻代区不足\",{\"1\":{\"52\":1}}],[\"当老年代中空间不足\",{\"1\":{\"44\":1}}],[\"当程序内存不足时\",{\"1\":{\"36\":1}}],[\"当对象被引用时加1\",{\"1\":{\"33\":1}}],[\"当线程执行完毕后\",{\"1\":{\"21\":1}}],[\"当二进制的各个位置都是1以后\",{\"1\":{\"10\":1}}],[\"当链表的长度>=8或数组容量>=64时\",{\"1\":{\"3\":1}}],[\"+\",{\"1\":{\"10\":1,\"40\":1}}],[\"<\",{\"1\":{\"10\":1}}],[\"8及以后\",{\"1\":{\"61\":1}}],[\"8\",{\"1\":{\"10\":1}}],[\"404\",{\"1\":{\"84\":1}}],[\"45\",{\"1\":{\"55\":1}}],[\"4\",{\"1\":{\"10\":1,\"83\":1}}],[\"2是46之后每升级一个大版本就加1\",{\"1\":{\"55\":1}}],[\"2048计算得到\",{\"1\":{\"52\":1}}],[\"2024\",{\"1\":{\"1\":1}}],[\"2之后提供了weakreference类来实现弱引用\",{\"1\":{\"37\":1}}],[\"2之后提供了softreference类来实现软引用\",{\"1\":{\"36\":1}}],[\"2\",{\"1\":{\"10\":1,\"65\":1}}],[\"|=\",{\"1\":{\"10\":5}}],[\"123\",{\"1\":{\"82\":1}}],[\"1使用了45\",{\"1\":{\"55\":1}}],[\"1\",{\"1\":{\"10\":5,\"21\":1,\"36\":1,\"37\":1,\"55\":3,\"65\":1,\"83\":1}}],[\"16\",{\"1\":{\"9\":2,\"10\":1}}],[\"technology\",{\"0\":{\"87\":1}}],[\"total是java虚拟机已经分配的可用堆内存\",{\"1\":{\"81\":1}}],[\"total\",{\"1\":{\"81\":1}}],[\"tomcat通过这种方式实现应用之间类隔离\",{\"1\":{\"72\":1}}],[\"to\",{\"1\":{\"44\":1}}],[\"the\",{\"1\":{\"39\":1}}],[\"try\",{\"1\":{\"28\":1}}],[\"treenode或普通node\",{\"1\":{\"6\":1}}],[\"treenode对象包含5个元素\",{\"1\":{\"3\":1}}],[\"ticketlock\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"tablesizefor\",{\"1\":{\"10\":1}}],[\">\",{\"1\":{\"73\":4}}],[\">=\",{\"1\":{\"10\":1}}],[\">32\",{\"1\":{\"10\":1}}],[\">>>\",{\"1\":{\"9\":1,\"10\":5}}],[\"设置了初始化容量\",{\"1\":{\"10\":1}}],[\"增大了随机性\",{\"1\":{\"9\":1}}],[\"位\",{\"1\":{\"9\":1}}],[\"^\",{\"1\":{\"9\":1}}],[\"=\",{\"1\":{\"9\":1,\"10\":1}}],[\"==启动类加载器依然无法通过java代码获取到\",{\"1\":{\"69\":1}}],[\"==\",{\"1\":{\"9\":1}}],[\"hasqueuedpredecessors\",{\"1\":{\"23\":2}}],[\"hashcode\",{\"1\":{\"9\":1}}],[\"hash值计算出的哈希槽位置上的元素是否为空\",{\"1\":{\"5\":1}}],[\"hash\",{\"1\":{\"3\":1,\"9\":1}}],[\"hashmap的数据结构为node数组+node链表+treenode红黑树\",{\"1\":{\"3\":1}}],[\"hashmap\",{\"0\":{\"2\":1},\"1\":{\"11\":1}}],[\"hashmap是线程不安全的为什么还要使用\",{\"1\":{\"1\":1}}],[\"h\",{\"1\":{\"9\":3}}],[\"扰动函数\",{\"0\":{\"9\":1}}],[\"迁移到原位置+扩容位数\",{\"1\":{\"8\":1}}],[\"链表长度大于等于8\",{\"1\":{\"12\":1}}],[\"链表树化\",{\"0\":{\"12\":1}}],[\"链表\",{\"1\":{\"8\":1}}],[\"链表会转换成红黑树\",{\"1\":{\"3\":1}}],[\"以下几种方式会导致类的初始化\",{\"1\":{\"66\":1}}],[\"以二进制的方式存储\",{\"1\":{\"53\":1}}],[\"以作为下次回收时的参考依据\",{\"1\":{\"52\":1}}],[\"以完成初始化或扩容操作\",{\"1\":{\"7\":1}}],[\"以及是否需要扩容来决定新阈值的值\",{\"1\":{\"7\":1}}],[\"以及通过\",{\"1\":{\"5\":1}}],[\"并为静态变量赋值\",{\"1\":{\"66\":1}}],[\"并有较高的吞吐量\",{\"1\":{\"52\":1}}],[\"并且容易产生大量的对象\",{\"1\":{\"50\":1}}],[\"并发收集\",{\"1\":{\"51\":1}}],[\"并发清理\",{\"1\":{\"49\":1,\"52\":1}}],[\"并发标记的satb算法效率高\",{\"1\":{\"52\":1}}],[\"并发标记\",{\"1\":{\"49\":1,\"52\":1}}],[\"并在稍后由一条由finalizethread线程从队列中获取对象\",{\"1\":{\"38\":1}}],[\"并处理移除\",{\"1\":{\"27\":1}}],[\"并进入自旋比对\",{\"1\":{\"27\":1}}],[\"并共享内存和其他资源\",{\"1\":{\"25\":1}}],[\"并将旧哈希数组中的元素复制到新哈希数组中\",{\"1\":{\"7\":1}}],[\"并返回旧值\",{\"1\":{\"4\":1}}],[\"返回的仍然是null\",{\"1\":{\"69\":1}}],[\"返回刚刚移除的节点\",{\"1\":{\"6\":1}}],[\"返回同位元素的旧值\",{\"1\":{\"4\":1}}],[\"进行解锁操作\",{\"1\":{\"27\":1}}],[\"进行红黑树转换\",{\"1\":{\"12\":1}}],[\"进行后续处理\",{\"1\":{\"6\":1}}],[\"进行相应的移除操作\",{\"1\":{\"6\":1}}],[\"如17\",{\"1\":{\"10\":1}}],[\"如modcount和size\",{\"1\":{\"6\":1}}],[\"如果一条指令将一个值压入操作数栈\",{\"1\":{\"78\":1}}],[\"如果一个对象只有软引用关联到它\",{\"1\":{\"36\":1}}],[\"如果某个类加载器加载过就会直接返回\",{\"1\":{\"71\":1}}],[\"如果所有的父类加载器都无法加载该类\",{\"1\":{\"71\":1}}],[\"如果已经加载则直接返回\",{\"1\":{\"71\":1}}],[\"如果已经初始化\",{\"1\":{\"7\":1}}],[\"如果软件不支持该种类型就会出错\",{\"1\":{\"55\":1}}],[\"如果清理过程中发现没有足够的空region存放转移的对象\",{\"1\":{\"52\":1}}],[\"如果能满足对象分配的要求就不需要对整个堆进行回收\",{\"1\":{\"44\":1}}],[\"如果minorgc后对象的年龄达到阈值\",{\"1\":{\"44\":1}}],[\"如果eden区满\",{\"1\":{\"44\":1}}],[\"如果我们需要的是一个比较大的空间\",{\"1\":{\"41\":1}}],[\"如果耗时过长会影响其他对象的回收\",{\"1\":{\"38\":1}}],[\"如果内存依然不足\",{\"1\":{\"36\":1}}],[\"如果垃圾回收仍不能解决内存不足的问题\",{\"1\":{\"36\":1}}],[\"如果在一个线程观察另一个线程\",{\"1\":{\"20\":1}}],[\"如果为1\",{\"1\":{\"8\":1}}],[\"如果为0\",{\"1\":{\"8\":1}}],[\"如果还未初始化\",{\"1\":{\"7\":1}}],[\"如果未找到匹配节点则返回null\",{\"1\":{\"6\":1}}],[\"如果需要匹配value且值不匹配\",{\"1\":{\"6\":1}}],[\"如果需要维持原状\",{\"1\":{\"4\":1}}],[\"如果找到了匹配的元素\",{\"1\":{\"6\":1}}],[\"如果最终没有找到匹配的元素\",{\"1\":{\"5\":1}}],[\"如果后续元素不是红黑树节点\",{\"1\":{\"5\":1}}],[\"如果是写入动作会导致其他处理器中对应的内存无效\",{\"1\":{\"15\":1}}],[\"如果是\",{\"1\":{\"5\":1}}],[\"如果首个元素不匹配\",{\"1\":{\"5\":1}}],[\"如果匹配成功\",{\"1\":{\"6\":1}}],[\"如果匹配\",{\"1\":{\"5\":1}}],[\"如果以上条件都满足\",{\"1\":{\"5\":1}}],[\"如果插入新元素后\",{\"1\":{\"4\":1}}],[\"如果不需要维持原状\",{\"1\":{\"4\":1}}],[\"如果不存在同位元素\",{\"1\":{\"4\":2}}],[\"如果存在同位元素\",{\"1\":{\"4\":1}}],[\"如果哈希数组未初始化或容量不足\",{\"1\":{\"4\":1}}],[\"更新相关计数器和变量\",{\"1\":{\"6\":1}}],[\"直接内存并不在\",{\"1\":{\"83\":1}}],[\"直接内存\",{\"0\":{\"83\":1}}],[\"直接内存中为了及时知道直接内存对象不再使用\",{\"1\":{\"38\":1}}],[\"直接引用就是不在使用编号来访问内容\",{\"1\":{\"73\":1}}],[\"直接访问父类的静态变量\",{\"1\":{\"66\":1}}],[\"直接会将代码中的值进行赋值\",{\"1\":{\"64\":1}}],[\"直接返回null\",{\"1\":{\"6\":1}}],[\"直到清零释放锁\",{\"1\":{\"21\":1}}],[\"直到找到匹配的元素或遍历结束\",{\"1\":{\"5\":1}}],[\"根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的survivor区中\",{\"1\":{\"52\":1}}],[\"根据新容量和旧容量的关系\",{\"1\":{\"7\":1}}],[\"根据给定的key和hash查找对应的同位元素\",{\"1\":{\"6\":1}}],[\"根据给定的哈希值和键值对\",{\"1\":{\"4\":1}}],[\"根据key值通过扰动函数计算hash值\",{\"1\":{\"5\":1}}],[\"哈希数组的容量超过了阈值\",{\"1\":{\"4\":1}}],[\"即吞吐量=执行用户代码时间\",{\"1\":{\"40\":1}}],[\"即是gcroot对象对普通对象有引用关系\",{\"1\":{\"35\":1}}],[\"即能否通过栈内存中的引用访问到实例对象\",{\"1\":{\"32\":1}}],[\"即使是自旋也是耗费性能的\",{\"1\":{\"28\":1}}],[\"即如果在本线程内观察\",{\"1\":{\"20\":1}}],[\"即不覆盖旧值\",{\"1\":{\"4\":1}}],[\"即哈希值和键都相同的元素\",{\"1\":{\"4\":1}}],[\"则后面的指令可以弹出并使用该值\",{\"1\":{\"78\":1}}],[\"则由当前类加载器自己尝试加载\",{\"1\":{\"71\":1}}],[\"则位置不变\",{\"1\":{\"8\":1}}],[\"则根据是否指定了初始容量来决定容量和阈值的初始值\",{\"1\":{\"7\":1}}],[\"则根据当前容量和最大容量来决定是否需要扩容\",{\"1\":{\"7\":1}}],[\"则根据节点类型\",{\"1\":{\"6\":1}}],[\"则根据matchvalue参数决定是否需要进一步匹配value\",{\"1\":{\"6\":1}}],[\"则不移除元素\",{\"1\":{\"6\":1}}],[\"则遍历哈希槽上的后续元素\",{\"1\":{\"5\":1}}],[\"则在红黑树中进行查找\",{\"1\":{\"5\":1}}],[\"则判断其后续元素是否为红黑树节点\",{\"1\":{\"5\":1}}],[\"则进一步判断首个元素是否与给定的key和hash值匹配\",{\"1\":{\"5\":1}}],[\"则返回该元素\",{\"1\":{\"5\":1}}],[\"则返回null\",{\"1\":{\"4\":1,\"5\":1}}],[\"则返回同位元素的旧值\",{\"1\":{\"4\":1}}],[\"则需要对哈希数组进行扩容\",{\"1\":{\"4\":1}}],[\"则需要先初始化或扩容哈希数组\",{\"1\":{\"4\":1}}],[\"则更新同位元素的值为新值\",{\"1\":{\"4\":1}}],[\"则将新元素插入到哈希槽中\",{\"1\":{\"4\":1}}],[\"在类的加载阶段完成\",{\"1\":{\"82\":1}}],[\"在类加载的过程中\",{\"1\":{\"71\":1}}],[\"在hotspot虚拟机中\",{\"1\":{\"80\":1}}],[\"在编译期就可以确认操作数栈的最大深度\",{\"1\":{\"78\":1}}],[\"在多线程执行情况下\",{\"1\":{\"75\":1}}],[\"在多核cpu下效率较高\",{\"1\":{\"51\":1}}],[\"在方法区中生成一个instanceklass对象\",{\"1\":{\"61\":1}}],[\"在字段或者字节码指令中通过编号可以快速的找到对应的数据\",{\"1\":{\"56\":1}}],[\"在虚拟机的默认设置中\",{\"1\":{\"44\":1}}],[\"在程序启动之后就不会被回收了\",{\"1\":{\"44\":1}}],[\"在垃圾回收gc阶段\",{\"1\":{\"42\":1}}],[\"在这个过程中可以在finalize方法中再将自身对象使用强引用关联上\",{\"1\":{\"38\":1}}],[\"在常规开发中不会使用\",{\"1\":{\"38\":1}}],[\"在软引用中包含的对象被回收时\",{\"1\":{\"36\":1}}],[\"在jdk\",{\"1\":{\"36\":1,\"37\":1,\"83\":1}}],[\"在堆中不存在任何该类的实例对象以及子类对象\",{\"1\":{\"31\":1}}],[\"在实际的使用中一般默认会选择非公平锁\",{\"1\":{\"28\":1}}],[\"在读写同一个变量\",{\"1\":{\"27\":1}}],[\"在\",{\"1\":{\"22\":1,\"25\":1}}],[\"在使用\",{\"1\":{\"22\":1}}],[\"在链表树化过程中记录了链表顺序\",{\"1\":{\"13\":1}}],[\"在创建\",{\"1\":{\"11\":1}}],[\"在put时会通过扩容函数resize函数进行初始化\",{\"1\":{\"10\":1}}],[\"在没有设置初始化容量时\",{\"1\":{\"10\":1}}],[\"在哈希槽中查找是否存在与新元素同位的元素\",{\"1\":{\"4\":1}}],[\"在数组的每个位置是一个链表\",{\"1\":{\"3\":1}}],[\"计算出该元素应当插入的哈希槽\",{\"1\":{\"4\":1}}],[\"root对象是科大的\",{\"1\":{\"34\":1}}],[\"resolve\",{\"0\":{\"85\":1}}],[\"resolveclass\",{\"1\":{\"73\":1}}],[\"register\",{\"0\":{\"75\":1}}],[\"region\",{\"1\":{\"52\":1}}],[\"region的大小通过堆空间大小\",{\"1\":{\"52\":1}}],[\"reentrantlock\",{\"0\":{\"22\":1},\"1\":{\"22\":1,\"28\":2}}],[\"return\",{\"1\":{\"9\":1,\"10\":1}}],[\"remove流程\",{\"0\":{\"6\":1}}],[\"red\",{\"1\":{\"3\":1}}],[\"right\",{\"1\":{\"3\":1}}],[\"platformclassloader\",{\"1\":{\"70\":1}}],[\"public\",{\"1\":{\"55\":1,\"73\":1}}],[\"put流程\",{\"0\":{\"4\":1}}],[\"parallel\",{\"0\":{\"50\":1,\"51\":1},\"1\":{\"50\":1,\"51\":1}}],[\"parnew垃圾回收器本质上是对serial在多cpu下的优化\",{\"1\":{\"48\":1}}],[\"parnew垃圾回收器\",{\"0\":{\"48\":1}}],[\"parent\",{\"1\":{\"3\":1}}],[\"program\",{\"0\":{\"75\":1}}],[\"protected\",{\"1\":{\"73\":3}}],[\"processor\",{\"1\":{\"25\":1}}],[\"prev\",{\"1\":{\"3\":1}}],[\"len\",{\"1\":{\"73\":1}}],[\"left\",{\"1\":{\"3\":1}}],[\"linking\",{\"0\":{\"62\":1}}],[\"linux的操作有哪些\",{\"1\":{\"1\":1}}],[\"long和double类型占用两个槽\",{\"1\":{\"77\":1}}],[\"loadclass\",{\"1\":{\"73\":1}}],[\"loading\",{\"0\":{\"61\":1}}],[\"lock\",{\"1\":{\"22\":3,\"27\":1,\"28\":1}}],[\"lang\",{\"1\":{\"31\":1,\"34\":1,\"61\":1}}],[\"name\",{\"1\":{\"73\":3}}],[\"new一个该类的对象时\",{\"1\":{\"66\":1}}],[\"new\",{\"1\":{\"36\":1}}],[\"next\",{\"1\":{\"3\":1,\"26\":1}}],[\"not\",{\"1\":{\"84\":1}}],[\"non\",{\"1\":{\"25\":1}}],[\"node对象包含4个元素\",{\"1\":{\"3\":1}}],[\"numa\",{\"1\":{\"25\":1,\"28\":1}}],[\"null\",{\"1\":{\"9\":1}}],[\"n\",{\"1\":{\"10\":14}}],[\"key计算而来的\",{\"1\":{\"5\":1}}],[\"key\",{\"1\":{\"3\":1,\"9\":3}}],[\"哪个hashmap是线程安全的\",{\"1\":{\"1\":1}}],[\"jclasslib\",{\"1\":{\"53\":1}}],[\"jdk7之后版本\",{\"1\":{\"82\":1}}],[\"jdk7之后版本由于字符串常量池在堆上\",{\"1\":{\"82\":1}}],[\"jdk9\",{\"1\":{\"69\":1,\"70\":1}}],[\"jdk9之后默认的垃圾回收器是g1\",{\"1\":{\"52\":1}}],[\"jdk9之后建议默认使用\",{\"1\":{\"52\":1}}],[\"jdk\",{\"1\":{\"55\":4,\"61\":1}}],[\"jdk8与jdk9\",{\"1\":{\"70\":1}}],[\"jdk8\",{\"1\":{\"69\":1,\"70\":1}}],[\"jdk8最新版本\",{\"1\":{\"52\":1}}],[\"jdk8之前还不够成熟\",{\"1\":{\"52\":1}}],[\"jdk8及之前的版本中\",{\"1\":{\"48\":1}}],[\"java堆中的对象如果不再使用要回收\",{\"1\":{\"83\":1}}],[\"java代码实现\",{\"0\":{\"70\":1}}],[\"java虚拟机会继续分配内存给堆\",{\"1\":{\"81\":1}}],[\"java虚拟机会将字节码中的信息保存到内存的方法区中\",{\"1\":{\"61\":1}}],[\"java虚拟机会将字节码中的信息保存到方法区中\",{\"1\":{\"61\":1}}],[\"java虚拟机栈和本地方法栈实现上使用了同一个栈空间\",{\"1\":{\"80\":1}}],[\"java虚拟机栈存储了java方法调用时的栈帧\",{\"1\":{\"80\":1}}],[\"java虚拟机栈随着线程的创建而创建\",{\"1\":{\"76\":1}}],[\"java虚拟机栈采用栈的数据结构来管理方法调用中的基本数据\",{\"1\":{\"76\":1}}],[\"java虚拟机栈\",{\"0\":{\"76\":1}}],[\"java虚拟机需要通过程序计数器记录cpu切换前解释执行到那一句指令并继续解释运行\",{\"1\":{\"75\":1}}],[\"java虚拟机在运行java程序过程中管理的内存区域\",{\"1\":{\"74\":1}}],[\"java虚拟机规范\",{\"1\":{\"62\":1,\"63\":1,\"83\":1}}],[\"java虚拟机还会在堆中生成一份与方法区中数据类似的java\",{\"1\":{\"61\":1}}],[\"java\",{\"0\":{\"76\":1,\"86\":1},\"1\":{\"55\":2,\"69\":1}}],[\"javap\",{\"1\":{\"53\":1}}],[\"java编写的客户端程序或者硬件配置有限的场景\",{\"1\":{\"46\":1}}],[\"java垃圾回收过程会通过单独的gc线程来完成\",{\"1\":{\"39\":1}}],[\"java中使用可达性分析算法\",{\"1\":{\"41\":1,\"43\":1}}],[\"java中使用phantomreference实现了虚引用\",{\"1\":{\"38\":1}}],[\"java中的对象是否能被回收\",{\"1\":{\"32\":1}}],[\"java锁\",{\"0\":{\"14\":1}}],[\"java后端研发实习\",{\"1\":{\"1\":1}}],[\"jvm\",{\"0\":{\"88\":1},\"1\":{\"1\":1}}],[\"0\",{\"1\":{\"9\":1,\"10\":1,\"11\":1,\"55\":2}}],[\"05\",{\"1\":{\"1\":1}}],[\"06\",{\"1\":{\"1\":1}}],[\"岗位\",{\"1\":{\"1\":1}}],[\"北京合思汇智信息技术有限公司\",{\"0\":{\"1\":1}}],[\"面试经历\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
